<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>為你的網站導入 GA4 - GA4 與 GTM 串接</title>
    <url>/2021/05/02/GA4CascadGTMe/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>商品行網站，常常會需要建立一些資料，來明白使用者動作，所以會使用到 GA (Google Analytics) 來追蹤使用者型為，這邊就來介紹一下新版 GA 4 、以及 GTM 串接設定。
</p>

<h2 id="開啟 GA4 、GTM 功能">開啟 GA4 、GTM 功能</h2>
<p>再有登入 google 狀況下，前往<a href="https://marketingplatform.google.com/info?authuser=1">此頁</a> ，在點擊 ，選單中 Analytics (分析)、 代碼管理工具 (GTM) ，在填寫一下相關資訊，就可以開啟 GA 、 GTM 的功能了。</p>
<img src="https://i.imgur.com/sWTFwqG.png">

<h2 id="GA 與 GTM 的關係">GA 與 GTM 的關係</h2>
<p>GA 本身就具有蒐集資料的功能，不過廠商時常會希望能夠紀錄使用者某些特定動作。
<br>
例如：記錄使用者登入網站的次數，這種特別事件的紀錄，就會需要使用 GTM 來做詳細的事件設定，因此許多網站會採用 GA 串接 GTM 做法。</p>

<h2 id="GA 串接 GTM">GA 串接 GTM</h2>
<p>接者我們會需要把 GA 和 GTM 串接起來這個步驟其實非常容易。
<br>
<ul>
  <li>步驟一：在 GA 首頁，點選左下角齒輪 (管理)</li>
  <li>步驟二：點選資料串流</li>
  <li>步驟三：點選你設定好的網址
    <br>
    <img src="https://i.imgur.com/m0pTEZV.png">
  </li>
  <li>步驟四：點選設定好的網址後，就會跳出新的選單，裡面有我們需要的 <b>評估 ID</b> ，接者就是把 <b>評估 ID</b> 複製至起來。
      <img src="https://i.imgur.com/QTHaKLZ.png">
  </li>
  <li>步驟五：接下會到 GTM 首頁，點選左側欄位的代碼，進入後按新增。
  </li>
  <li>步驟六：代碼類型選擇 <b>Google Analytics (分析)：GA4 設定</b> 接者 GTM 這邊會多一個 <b>評估 ID </b> 的欄位，這邊當然是放入 GA 複製過來的 <b>評估 ID</b>。 
  </li>
  <li>步驟七：下方的觸發條件欄位選擇 <b>All Pages</b>，接下來就是按下右上角儲存。 
    <img src="https://i.imgur.com/yFoJLxn.png">
  </li>
  <li>步驟八：這是最後的一步驟了，可以目前看到 GTM 右上角有寫到 <b>工作區變更數： 1</b> 要做的就是按下提交，把剛剛 GTM 的設定發布出去，這樣就完成 GA 與 GTM 串接了。</li>
</ul>
</p>

<h2 id="為你的網站導入 GTM">為你的網站導入 GTM</h2>
<p>在上述八個步驟後，在按上右上角的發布其實已經完成 GA 與 GTM 的串連，此時 GA 暫時不會用到，接者只需要獲得 GTM 的 CDN 在把它放到你的專案中，就大功告成了。
<br>
而獲得 GTM CDN 也非常簡單，在 GTM 點擊管理 => 環境 => 動作 => 取得程式碼片段 ，此時就會獲得 GTM CDN 碼了。
  <img src="https://i.imgur.com/K3zNweI.png">
<br>
接者就可以根據說明把 CDN 碼，放入對應 HTML 位置，你的網站就有 GA 追蹤功能了。
<br>
下面一篇會開始說明一下，GTM 的一些操作方法。]]></content>
      <categories>
        <category>Google Analytics</category>
      </categories>
      <tags>
        <tag>Google Analytics</tag>
        <tag>GA4</tag>
        <tag>GTM</tag>
      </tags>
  </entry>
  <entry>
    <title>GTM 測試功能和瀏覽即時的 GA 紀錄</title>
    <url>/2021/05/09/GTM-testing-and-GTM-Built-in-event/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>上回我們說到，GTM  串接 GA 後再用 CDN 綁到底自己專案上，本次則來介紹如何測試 GTM 是否能正確使用，以及如何觀察即時更新 GA 紀錄。</p>

<h2 id="開啟 GTM 測試功能">開啟 GTM 測試功能</h2>
<p>先介紹一下GTM 測試功能，進入 GTM 首頁後，右上角會有預覽、以及提交兩個按鈕，如果想要進入測試功能，就點擊預覽。</p>
<img src="https://i.imgur.com/Fb1dRMT.png">
<br>
<p>點擊預覽後會開啟新的頁面叫做 Google Tag Assistant ，這時我們要輸入先前介紹的，有該 GTM CDN 的網址，這邊不管輸入的是 local 端網址、還是實際的線上網址，只有網址有設定 GTM 的CDN 就沒有問題了，這邊我使用本地的 <code>http://127.0.0.1:5500/index.html</code> 網址做測試，網址輸入後就按下 Connect 按鈕拉。
</p>
<img src="https://i.imgur.com/Oohk10l.png">
<br>

<p>
按下 Connect 按鈕後會馬上跳出，剛剛輸入網址的頁面，並且這頁面網址最後方帶有 <code>?gtm_debug=x</code>，接著大約等個 10 秒後， Tag Assistant 頁面會跳出 Connected 的視窗，這就代表你的 GTM 有成功設置囉!
</p>
<img src="https://i.imgur.com/uDUJ2LY.png">
<br>
<h2 id="部分 GTM 內建事件介紹">部分 GTM 內建事件介紹</h2>
<p>
GTM 本身預設會帶有監測部分動作的事件，我們接下來可以在剛剛 GTM 開啟的頁面中，做一些動作。<span style="font-size:14px">(帶有 ?gtm_debug=X 的那個頁面)
</span>
<br>
會發現 Tag Assistant 頁面的左邊欄位會去記錄部分事件，比如: <b>Scroll Depth</b> 就是使用者把網頁滑到底、而 <b>Link Click</b> 則是在使用者在網頁中點擊任意連結。
</p>
<img src="https://i.imgur.com/bhbJJaH.png">
<br>
<h2 id ="觀看 GA 即時事件">觀看 GA 即時事件</h2>
<p>而這些紀錄也都會存到和 GTM 綁定的 GA 上，這時我們到 GA 的即時、DebugView 頁面也都會看到這些紀錄。</p>
<img src="https://i.imgur.com/dW4rPMd.png">
<img src="https://i.imgur.com/Lvx2QYE.png">
<br>
<p>值得一提的是， GA 上的即時、DebugView 頁面，只會顯示最近 30 分鐘的網頁事件，超過 30 分鐘就看不到了。
<br>
而 GA 其他的瀏覽方式，如報表、首頁都會需要等待一天，GA 才會把資料做更新，所以在要 Debug GTM 事件的狀況下，工程師一般都會觀察 即時、DebugView 頁面。
<br>
下面一篇會開始說明，如何新增 GTM 的內建事件 。
</p>]]></content>
      <categories>
        <category>Google Analytics</category>
      </categories>
      <tags>
        <tag>Google Analytics</tag>
        <tag>GA4</tag>
        <tag>GTM</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day10) 物件基礎介紹</title>
    <url>/2021/10/02/JS-core/(Day10)%20%E7%89%A9%E4%BB%B6%E5%9F%BA%E7%A4%8E%E4%BB%8B%E7%B4%B9/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>物件 在 JS 是十分重要的，並且關於物件有幾個滿重要的特性：</p>
<ul>
<li>物件傳參考</li>
<li>物件深層/淺層 複製</li>
</ul>
<p>不過在這之前先來介紹物件基礎概念及操作 （<del>混文章</del>）</p>
<h2 id="物件結構"><a href="#物件結構" class="headerlink" title="物件結構"></a>物件結構</h2><p>物件是有以下東西組成的： </p>
<ul>
<li>物件最外層的 <code>&#123;&#125;</code> 一般稱作物件實字 (Object Literals)。</li>
<li>再來是物件實字中的內容是由 <code>屬性(property)</code> /  <code>值(value)</code> 組成。</li>
</ul>
<p>而物件的值可以是任何純值、陣列、物件本身以及函式：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> school = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;Taipei University&#x27;</span>,</span><br><span class="line">	<span class="attr">age</span>:<span class="number">45</span>,</span><br><span class="line">	<span class="attr">vacation</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="attr">teacher</span>:[<span class="string">&#x27;Mike&#x27;</span>,<span class="string">&#x27;Lisha&#x27;</span>,<span class="string">&#x27;Bob&#x27;</span>],</span><br><span class="line">	<span class="attr">classes</span>: &#123;</span><br><span class="line">		<span class="attr">student</span>:[<span class="string">&#x27;Kevin&#x27;</span>,<span class="string">&#x27;Clara&#x27;</span>,<span class="string">&#x27;Rose&#x27;</span>],</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">broadcast</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;學校廣播&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="物件取值"><a href="#物件取值" class="headerlink" title="物件取值"></a>物件取值</h2><p>在 JS有兩種方法可以獲得物件中的值:</p>
<ul>
<li>使用 <code>.</code> 點運算子</li>
<li>使用中刮號 <code>[]</code></li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> school = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;Taipei University&#x27;</span>,</span><br><span class="line">	<span class="attr">age</span>:<span class="number">45</span>,</span><br><span class="line">	<span class="attr">vacation</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="attr">teacher</span>:[<span class="string">&#x27;Mike&#x27;</span>,<span class="string">&#x27;Lisha&#x27;</span>,<span class="string">&#x27;Bob&#x27;</span>],</span><br><span class="line">	<span class="attr">classes</span>: &#123;</span><br><span class="line">		<span class="attr">student</span>:[<span class="string">&#x27;Kevin&#x27;</span>,<span class="string">&#x27;Clara&#x27;</span>,<span class="string">&#x27;Rose&#x27;</span>],</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">broadcast</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;學校廣播&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">school.name <span class="comment">//Taipei University</span></span><br><span class="line">school[<span class="string">&#x27;age&#x27;</span>] <span class="comment">//45</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>[]</code> 方法取值，有個好處，是可以透過變數替換 <code>[]</code> 中的值，來取出物件中不同的值，也就是：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> school = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;Taipei University&#x27;</span>,</span><br><span class="line">	<span class="attr">age</span>:<span class="number">45</span>,</span><br><span class="line">	<span class="attr">vacation</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="attr">teacher</span>:[<span class="string">&#x27;Mike&#x27;</span>,<span class="string">&#x27;Lisha&#x27;</span>,<span class="string">&#x27;Bob&#x27;</span>],</span><br><span class="line">	<span class="attr">classes</span>: &#123;</span><br><span class="line">		<span class="attr">student</span>:[<span class="string">&#x27;Kevin&#x27;</span>,<span class="string">&#x27;Clara&#x27;</span>,<span class="string">&#x27;Rose&#x27;</span>],</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">broadcast</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;學校廣播&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test =<span class="string">&#x27;name&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(school[test]) <span class="comment">// Taipei University</span></span><br><span class="line">test = <span class="string">&#x27;age&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(school[test]) <span class="comment">// 45</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而這個特性 使用 <code>.</code>  運算子，便無法達成了，按照上面範例使用  <code>school.test</code>  他會回傳 <code>undefined</code> 。</p>
<p>值得一題的是物件中的屬性都會是字串，當屬性不是字串時， JS 會自動將物件屬性強制轉成字串，因此我們實際上在建立物件時，通常會直接忽略屬性要寫成字串這點。</p>
<p>也因此物件屬性是能添加某些特殊符號，不過是只能使用 <code>[]</code> 來取值的，而 <code>.</code> 運算子則無法正確使用。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj= &#123;</span><br><span class="line">	<span class="string">&#x27;obj-test&#x27;</span>:<span class="string">&#x27;測試文字&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj.obj-test <span class="comment">// test is not defined</span></span><br><span class="line">obj[<span class="string">&#x27;obj-test&#x27;</span>] <span class="comment">//測試文字</span></span><br></pre></td></tr></table></figure>

<h2 id="新增屬性"><a href="#新增屬性" class="headerlink" title="新增屬性"></a>新增屬性</h2><p>實際上若要在物件新增屬性，方法就跟物件取值一樣使用 <code>.</code> 運算子或是 <code>[]</code> 指向新屬性，接著再使用 <code>=</code>  為該屬性賦值。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> school = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;Taipei University&#x27;</span>,</span><br><span class="line">	<span class="attr">age</span>:<span class="number">45</span>,</span><br><span class="line">	<span class="attr">vacation</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="attr">teacher</span>:[<span class="string">&#x27;Mike&#x27;</span>,<span class="string">&#x27;Lisha&#x27;</span>,<span class="string">&#x27;Bob&#x27;</span>],</span><br><span class="line">	<span class="attr">classes</span>: &#123;</span><br><span class="line">		<span class="attr">student</span>:[<span class="string">&#x27;Kevin&#x27;</span>,<span class="string">&#x27;Clara&#x27;</span>,<span class="string">&#x27;Rose&#x27;</span>],</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">broadcast</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;學校廣播&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">school.phoneNumber = <span class="string">&#x27;02-4050331&#x27;</span></span><br><span class="line">school[<span class="string">&#x27;address&#x27;</span>] = <span class="string">&#x27;台北市中正區北平西路3號&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(school.phoneNumber,school[<span class="string">&#x27;address&#x27;</span>]) <span class="comment">// &#x27;02-4050331&#x27; , &#x27;台北市中正區北平西路3號&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="刪除屬性"><a href="#刪除屬性" class="headerlink" title="刪除屬性"></a>刪除屬性</h2><p>要刪除屬性也很簡單，直接使用一元運算子 <code>delete</code> 再使用 <code>.</code> 或 <code>[]</code> 指向要刪除的屬性。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> school = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;Taipei University&#x27;</span>,</span><br><span class="line">	<span class="attr">age</span>:<span class="number">45</span>,</span><br><span class="line">	<span class="attr">vacation</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="attr">teacher</span>:[<span class="string">&#x27;Mike&#x27;</span>,<span class="string">&#x27;Lisha&#x27;</span>,<span class="string">&#x27;Bob&#x27;</span>],</span><br><span class="line">	<span class="attr">classes</span>: &#123;</span><br><span class="line">		<span class="attr">student</span>:[<span class="string">&#x27;Kevin&#x27;</span>,<span class="string">&#x27;Clara&#x27;</span>,<span class="string">&#x27;Rose&#x27;</span>],</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">broadcast</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;學校廣播&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> school.age</span><br><span class="line"><span class="built_in">console</span>.log(school.age) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="ES6-物件函式縮寫"><a href="#ES6-物件函式縮寫" class="headerlink" title="ES6 物件函式縮寫"></a>ES6 物件函式縮寫</h2><p>上面有提到物件中也能使用函式，正確的寫法會是</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> school = &#123;</span><br><span class="line">	<span class="attr">broadcast</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;學校廣播&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">school.broadcast() <span class="comment">// 學校廣播</span></span><br></pre></td></tr></table></figure>

<p>而 ES6 則為物件函式提供了縮寫，可以省略  <code>:function</code> 直接寫成 :</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> school = &#123;</span><br><span class="line">	<span class="function"><span class="title">broadcast</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;學校廣播&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">school.broadcast() <span class="comment">// 學校廣播</span></span><br></pre></td></tr></table></figure>

<p>在使用一些大型框架時會很常看到這個縮寫方法。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li>JavaScript 核心篇 (六角學院）</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day11) 物件參考特性</title>
    <url>/2021/10/02/JS-core/(Day11)%20%E7%89%A9%E4%BB%B6%E5%8F%83%E8%80%83%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="傳值與傳參考"><a href="#傳值與傳參考" class="headerlink" title="傳值與傳參考"></a>傳值與傳參考</h2><p>物件傳參考是 JS 中非常重要的特性，純值和物件在賦值時的行為模式不同：<br>​</p>
<ul>
<li>純值在賦值時會是傳值</li>
<li>物件型別都是傳參考（參考記憶體）<br>​<br>先來看看傳值的程式碼：<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name1 = <span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line"><span class="keyword">var</span> name2 = name1</span><br><span class="line">name2 = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log( name1, name2 )<span class="comment">//Ryder , Jack </span></span><br></pre></td></tr></table></figure>
<h2 id="傳參考範例"><a href="#傳參考範例" class="headerlink" title="傳參考範例"></a>傳參考範例</h2>這個狀況很好理解，name1 的資料賦值給 name2，nam2 獨立修改資料，不影響 name1 ，但如果是物件的傳參考狀況呢？<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>:<span class="string">&#x27;Ryder&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1</span><br><span class="line"> obj2.name = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log( obj1.name ,obj2.name) <span class="comment">//Jack , Jack </span></span><br></pre></td></tr></table></figure>
答案會是兩邊都會是 Jack  ，並且若再使用 <code>console.log(obj1 === obj2)</code>  他也會回傳 <code>true</code> ，這是因為在 JS 中，物件賦值時是傳參考的。<br>​<br>那什麼是傳參考呢?<br>​<br>根據上面程式碼，一行一行來講解</li>
</ul>
<ol>
<li>首先再建立一個物件時，該物件便會創建一個記憶體，也就是範例中的：<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>:<span class="string">&#x27;Ryder&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>
這樣物件本就會有一個獨立的記憶體，目前稱做 00x1，情況大致如圖：<br><img src="https://i.imgur.com/Ma5le65.png"><br>​</li>
<li>再來 <code>obj2 = obj1</code>  當 <code>obj1</code> 賦值給  <code>obj2</code> 時，其實這段就是提供物件參考的記憶體，因此稱作傳參考，情況如圖：<br><img src="https://i.imgur.com/rsWVqPr.png"><br>也因為 <code>obj1</code> 、 <code>obj2</code> 的記憶體指向是相同記憶體，因此當我們使用 <code>obj2.name</code> 修改時，兩個物件的內容都會被修改。<br>​<h2 id="物件實字-建立新記憶體"><a href="#物件實字-建立新記憶體" class="headerlink" title="物件實字 {} 建立新記憶體"></a>物件實字 {} 建立新記憶體</h2>再來看看例外狀況：<br>試著為 <code>obj2</code> 賦予新物件:<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>:<span class="string">&#x27;Ryder&#x27;</span> &#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1</span><br><span class="line">obj2 = &#123; <span class="attr">name</span>:<span class="string">&#x27;Ryder&#x27;</span> &#125;</span><br><span class="line">connsole.log(obj1 === obj2) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
​<br>結果之所以回傳 <code>false</code>  是因為 <code>obj2</code>  有在使用物件實字 <code>&#123;&#125;</code>  建立一個新物件，此時會生成一個新的記憶體指向，用圖表示就是：<br><img src="https://i.imgur.com/lbMNb0W.png"><br>​<h2 id="特殊範例"><a href="#特殊範例" class="headerlink" title="特殊範例"></a>特殊範例</h2>最後來看看一個狀況特別的延伸的範例：<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>:<span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1</span><br><span class="line">obj1.a = &#123; <span class="attr">a</span>:<span class="number">2</span> &#125;</span><br><span class="line">obj1.b = obj1 = &#123; <span class="attr">b</span>:<span class="number">1</span> &#125; </span><br><span class="line">obj1 <span class="comment">//&#123;b: 1&#125;</span></span><br><span class="line">obj2 <span class="comment">//&#123;a: &#123;a:2&#125;, b: &#123;b:1&#125;&#125;</span></span><br></pre></td></tr></table></figure>
​<br>這邊出現的結果不論是 <code>obj1</code> 、<code>obj2</code> 都令人疑惑，這邊一行一行來說明：<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>:<span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure></li>
<li>obj1 創立一個物件此時誕生一個新記憶體 00x1 ，內容是 <code>&#123; a:1 &#125;</code> ，狀況如圖：<br><img src="https://i.imgur.com/jDslpcS.png"><br>​</li>
<li>obj2 賦值實際獲得的是 00x1 記憶體，如圖：<br><img src="https://i.imgur.com/PUqNjpM.png"><br>​</li>
<li>obj1  中的 a 屬性從原本純值 1 替換成新物件 <code>&#123; a:2 &#125;</code>，此時也會建立新記憶體 00x2 ，如圖：<br><img src="https://i.imgur.com/P1kYYHh.png"><br>​</li>
<li>接下來是重點  <code>obj1.b = obj1 = &#123; b:1 &#125;</code> 根據運算子相依性特性 <code>obj1 = &#123; b:1 &#125;</code>  會先執行，同時我們也看到 <code>obj1</code> 重新賦值一個新物件，因此會誕生一個新記憶體 00x3 ，並且 <code>obj1</code> 指向的記憶體會被更改成 00x3，如圖：<br><img src="https://i.imgur.com/3tiDZvV.png"><br>​</li>
<li>接下來是將 <code>obj1 = &#123; b:1 &#125;</code> 這段回傳的 <code>&#123; b:1 &#125;</code> 賦予到 <code>obj1.b</code>  上，但要注意的是我們輸入的是 <code>obj1.b = obj1 = &#123; b:1 &#125;</code>  這段只是一行程式碼，JS 實際上在編譯時不會為了  <code>obj1 = &#123; b:1 &#125;</code>  馬上建立一段新的記憶體，因此 <code>obj1.b</code>  實際指向的並非是後來變更的 00x3 而是變更前的 00x1 ，因此就會是 00x1 又塞入了 00x3 內容，如圖：<br><img src="https://i.imgur.com/GYxRlw6.png"><br>最後使用 <code>console.log(obj1 === obj2.b)</code> 答案也會是 true 了。<br>​<br>P.S. 最讓人疑問的便是 <code>obj1.b = obj1 = &#123; b:1 &#125;</code> 這段。<br>而這段的重點是，JS 在編譯這種一行執行的程式碼時，是不會為了個別『運算式』去建立記憶體，因此這種一行程式碼，都還是會使用原始的記憶體指向。<br>​<br>​<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2></li>
</ol>
<ul>
<li>JavaScript 核心篇 (六角學院）</li>
<li><a href="https://hsiangfeng.github.io/javascript/20200815/1875070167">JavaScript 核心觀念(27)-物件-物件參考觀念的實際運作模式</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day12) 物件，淺拷貝/深拷貝</title>
    <url>/2021/10/02/JS-core/(Day12)%20%E7%89%A9%E4%BB%B6%EF%BC%8C%E6%B7%BA%E6%8B%B7%E8%B2%9D&amp;%E6%B7%B1%E6%8B%B7%E8%B2%9D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>實作很常會遇到要讓物件複製出來，個別使用的狀況，在 JavaScript 物件複製分成兩種：</p>
<ul>
<li>淺拷貝</li>
<li>深拷貝</li>
</ul>
<h2 id="淺拷貝-shallow-copy"><a href="#淺拷貝-shallow-copy" class="headerlink" title="淺拷貝(shallow copy)"></a>淺拷貝(shallow copy)</h2><p>這邊先來看看淺拷貝的範例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> school = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;Taipei University&#x27;</span>,  </span><br><span class="line">	<span class="attr">classes</span>: &#123; </span><br><span class="line">		<span class="attr">teacher</span>: <span class="string">&#x27;Alex&#x27;</span>,</span><br><span class="line">		<span class="attr">student</span>:[<span class="string">&#x27;Kevin&#x27;</span>,<span class="string">&#x27;Clara&#x27;</span>,<span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newSchool = <span class="built_in">Object</span>.assign(&#123;&#125;, school)</span><br></pre></td></tr></table></figure>

<p>這樣就是典型的淺拷貝，接者修改 <code>newSchool</code> 的 <code>name</code> 屬性看看：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> school = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;Taipei University&#x27;</span>,  </span><br><span class="line">	<span class="attr">classes</span>: &#123; </span><br><span class="line">		<span class="attr">teacher</span>: <span class="string">&#x27;Alex&#x27;</span>,</span><br><span class="line">		<span class="attr">student</span>:[<span class="string">&#x27;Kevin&#x27;</span>,<span class="string">&#x27;Clara&#x27;</span>,<span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newSchool = <span class="built_in">Object</span>.assign(&#123;&#125;, school)</span><br><span class="line">newSchool.name = <span class="string">&#x27;Taoyuan University&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(school.name , newSchool.name)<span class="comment">// &#x27;Taipei University&#x27; , &#x27;Taoyuan University&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以發現 <code>newSchool</code>  的 <code>name</code> 確實獨立被修改了，不過要注意的是，這種淺拷貝方法只會對物件第一層的屬性生效，在第二層之下的仍然是上篇文章介紹的傳參考特性，這邊來看看修改第二層的範例： </p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> school = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;Taipei University&#x27;</span>,  </span><br><span class="line">	<span class="attr">classes</span>: &#123; </span><br><span class="line">		<span class="attr">teacher</span>: <span class="string">&#x27;Alex&#x27;</span>,</span><br><span class="line">		<span class="attr">student</span>:[<span class="string">&#x27;Kevin&#x27;</span>,<span class="string">&#x27;Clara&#x27;</span>,<span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newSchool = <span class="built_in">Object</span>.assign(&#123;&#125;, school)</span><br><span class="line">newSchool.classes.teacher = <span class="string">&#x27;Mary&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(school.classes.teacher, newSchool.classes.teacher) <span class="comment">// &#x27;Mary&#x27;, &#x27;Mary&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以發現第二層以下的屬性，兩個物件仍會按照傳參考特性一同被修改。</p>
<p>在原生 JS 中淺拷貝方法較多，其他還有:</p>
<ul>
<li>使用物件展開方法：</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> school = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;Taipei University&#x27;</span>,  </span><br><span class="line">	<span class="attr">classes</span>: &#123; </span><br><span class="line">		<span class="attr">teacher</span>: <span class="string">&#x27;Alex&#x27;</span>,</span><br><span class="line">		<span class="attr">student</span>:[<span class="string">&#x27;Kevin&#x27;</span>,<span class="string">&#x27;Clara&#x27;</span>,<span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newSchool = &#123; ...school &#125;</span><br><span class="line">newSchool.classes.teacher = <span class="string">&#x27;Mary&#x27;</span></span><br><span class="line">newSchool.name = <span class="string">&#x27;Taoyuan University&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(school.name , school.classes.teacher) <span class="comment">//Taipei University Mary</span></span><br></pre></td></tr></table></figure>

<ul>
<li>for … in 方法</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> school = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;Taipei University&#x27;</span>,  </span><br><span class="line">	<span class="attr">classes</span>: &#123; </span><br><span class="line">		<span class="attr">teacher</span>: <span class="string">&#x27;Alex&#x27;</span>,</span><br><span class="line">		<span class="attr">student</span>:[<span class="string">&#x27;Kevin&#x27;</span>,<span class="string">&#x27;Clara&#x27;</span>,<span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newSchool = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> school )&#123;</span><br><span class="line">newSchool[key] = school[key]</span><br><span class="line">&#125;</span><br><span class="line">newSchool.classes.teacher = <span class="string">&#x27;Mary&#x27;</span></span><br><span class="line">newSchool.name = <span class="string">&#x27;Taoyuan University&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(school.name , school.classes.teacher) <span class="comment">//Taipei University Mary</span></span><br></pre></td></tr></table></figure>

<p>不過實做中這種傳參考特性，有時反而達不到需求，這個時候就會想問了，JavaScript 中有沒有什麼方法，能複製兩個指向完全不同的物件？</p>
<p>而深拷貝就是能將物件記憶體指向完全分開的方法。</p>
<h2 id="深拷貝-deep-copy"><a href="#深拷貝-deep-copy" class="headerlink" title="深拷貝(deep copy)"></a>深拷貝(deep copy)</h2><p>和淺拷貝不同，能夠做到深拷貝的功能，在原生 JavaScript 中只有一種寫法，如範例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> school = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;Taipei University&#x27;</span>,  </span><br><span class="line">	<span class="attr">classes</span>: &#123; </span><br><span class="line">		<span class="attr">teacher</span>: <span class="string">&#x27;Alex&#x27;</span>,</span><br><span class="line">		<span class="attr">student</span>:[<span class="string">&#x27;Kevin&#x27;</span>,<span class="string">&#x27;Clara&#x27;</span>,<span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newSchool = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(school ))</span><br><span class="line">newSchool.classes.teacher = <span class="string">&#x27;Mary&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log( school.classes.teacher, newSchool.classes.teacher) <span class="comment">//Alex, Mary</span></span><br></pre></td></tr></table></figure>

<p>看到 <code>JSON.stringify()</code>  其實就會明白，這個方法是先透過 <code>JSON.stringify()</code> 將物件轉成字串，再使用 <code>JSON.parse()</code> 將字串轉成物件，由於有先轉成字串因此兩個物件的記憶體是完全分開的。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li>JavaScript 核心篇 (六角學院）</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day13) 函式基礎與參數介紹</title>
    <url>/2021/10/02/JS-core/(Day13)%20%E5%87%BD%E5%BC%8F%E5%9F%BA%E7%A4%8E%E8%88%87%E5%8F%83%E6%95%B8%E4%BB%8B%E7%B4%B9/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>函式在即使非 JavaScript  的程式語言中是非常重要的一塊，我們會根據需求在函式中建立一系列動作，需要的時候便接呼叫對應函式，不管需求是執行 Ajax API ，或是隱藏、顯示畫面中某某區塊，都會將這些需求寫在函式中。<br>​</p>
<h2 id="呼叫函式"><a href="#呼叫函式" class="headerlink" title="呼叫函式"></a>呼叫函式</h2><p>​<br>呼叫函式的方法，使用函式名稱搭配小刮號 <code>()</code><br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;一般函式&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">Fn1()</span><br></pre></td></tr></table></figure>
<p>​<br>也可以在小刮號中寫入參數，參數會帶到函式中，而函式的參數只跟在函式中建立的變數一樣，他的作用域只存在於函式中。<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num) <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line">Fn1(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">//num </span></span><br></pre></td></tr></table></figure>
<p>​<br>實做中常常看到在函式  <code>return</code>  某個值，而其實 <code>return</code> 的值會直接回傳在呼叫函式的方法中，這種方法常用在會要執行某些重複動作的需求上。<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = num + <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> sum </span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="built_in">console</span>.log(Fn1(<span class="number">1</span>) , Fn1(<span class="number">2</span>)) <span class="comment">//11, 12</span></span><br></pre></td></tr></table></figure>
<p>​</p>
<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>​<br>上面有介紹到函式帶參數功能，關於參數也有一個特別的功能，就是 <code>arguments</code> 。<br>​<br> <code>arguments</code>  這個語法在函式建立時，他也會被一同建立，即使我們不需告變數、參數他也會存在於函式中，而  <code>arguments</code>  其實就是我們呼叫函式時，所有參數組和而成的 <strong>類陣列。</strong><br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>) <span class="comment">//Arguments(3) [1, 2, 3, .... ]</span></span><br><span class="line">&#125;</span><br><span class="line">Fn1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>​<br>什麼是類陣列呢？簡單來講就是一個類似陣列但不是陣列的東西，但是類陣列與陣列最大差異在於可以<strong>使用的方法</strong> or <strong>功能</strong>會有很大差異，因此我們來看一下範例：<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.dir(a);</span><br></pre></td></tr></table></figure>
<p>​<br>點開變數 <code>a</code> 中的 <code>[[Prototype]]</code>  底下都會是陣列中的方法（太長因此不全部截圖）：<br><img src="https://i.imgur.com/YkWvvEn.png"><br>​<br>而 <code>arguments</code>  中的 <code>[[Prototype]]</code>  就只有：<br><img src="https://i.imgur.com/vBl8Yrb.png"><br>可以看的出來類陣列和原始陣列中的方法相差十分多。<br>​</p>
<h2 id="參數作用域"><a href="#參數作用域" class="headerlink" title="參數作用域"></a>參數作用域</h2><p>​<br>當我們參數名稱和函式外層變數相同時，看看花生神魔術<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name =<span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name) <span class="comment">// Jack</span></span><br><span class="line">&#125;</span><br><span class="line">Fn1(<span class="string">&#x27;Jack&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>​<br>結果會是以傳入參數為準。<br>那麼看看對參數使用 <code>=</code>  運算子賦予一個新的值看看結果如何：<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    name = <span class="string">&#x27;Annie&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(name) <span class="comment">// Annie</span></span><br><span class="line">&#125;</span><br><span class="line">Fn1(<span class="string">&#x27;Jack&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>​<br>結果會發現參數的值確實可以更改，其實參數跟函式中變數的範圍練特性是差不多的，當內層有該參數時，就會優先指向內層參數。<br>​</p>
<h2 id="ES6-預設參數"><a href="#ES6-預設參數" class="headerlink" title="ES6 預設參數"></a>ES6 預設參數</h2><p>​<br>在 ES6 語法中有新增一個預設參數方法，只需在參數旁邊使用 <code>=</code> 運算子賦值，之後呼叫函式時，若沒帶上參數，到了函式中參數便會套上預設的值，但如果呼叫函式時，有帶上參數，便還是以帶上的參數為主，是一個十分方變的功能:<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params">name = <span class="string">&#x27;Annie&#x27;</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Fn1()) <span class="comment">//Annie</span></span><br><span class="line"><span class="built_in">console</span>.log(Fn1(<span class="string">&#x27;Jack&#x27;</span>)) <span class="comment">//Jack</span></span><br><span class="line">​</span><br></pre></td></tr></table></figure>
<p>​</p>
<h2 id="參數與物件傳參考"><a href="#參數與物件傳參考" class="headerlink" title="參數與物件傳參考"></a>參數與物件傳參考</h2><p>​<br>先前也有介紹到物件傳參考這個特性，當我們物件傳入參數時，他也會是傳參考， :<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>:<span class="string">&#x27;Ryder&#x27;</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    item.name = <span class="string">&#x27;Annie&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(item.name, obj1.name) <span class="comment">// Annie , Annie</span></span><br><span class="line">&#125;</span><br><span class="line">Fn1(obj1 )</span><br></pre></td></tr></table></figure>
<p>範例中兩個物件的 <code>name</code> 屬性的值也都會改成 <code>&#39;Annie&#39;</code> 。<br>不過當我們只是傳入物件中的屬性時，結果並非是傳參考，而僅僅是傳值<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name</span>:<span class="string">&#x27;Ryder&#x27;</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    item = <span class="string">&#x27;Annie&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(item, obj1.name) <span class="comment">// Annie , Ryder</span></span><br><span class="line">&#125;</span><br><span class="line">Fn1(obj1.name)</span><br></pre></td></tr></table></figure>
<p>​<br>因此有使用 ES Lint 時，如果有試者修改參數的值，他都會跳出請不要直接修改參數的相關警告，這點就是避免物件傳參考特性發生錯誤。<br>​</p>
<h2 id="函式分類"><a href="#函式分類" class="headerlink" title="函式分類"></a>函式分類</h2><p>​<br>最後來說說函式的分類，在先前 陳述式 /表達式 中有根據建立方法不同，將函式分成：<br>​</p>
<ul>
<li>函示陳述式(具名函式)</li>
<li>函式表達式(匿名函式)<br>​<br>但這其實是根據這段語法是表達式、陳述式來做區分，或者說函式有沒有名字來做分類的，在 ES6 新增箭頭函式後，一般會把函式分成三種：<br>​</li>
<li>一般傳統函式（又可分為 具名函式、匿名函式）<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;傳統具名&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">Fn1() </span><br><span class="line">​</span><br><span class="line"><span class="keyword">var</span> Fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;傳統匿名&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">Fn2()</span><br></pre></td></tr></table></figure>
​</li>
<li>立即函式（IIFE），一般都是以 匿名函式 寫成，雖然也可寫成具名函式，不過這種寫法很少看到：<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;立即函式&#x27;</span>)</span><br><span class="line">&#125;)() </span><br></pre></td></tr></table></figure>
​</li>
<li>ES6 新增的箭頭函式，箭頭函式一律都是匿名函式，設計上就無法使用具名函式寫成：<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Fn3 = <span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;箭頭函式&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">Fn3()</span><br></pre></td></tr></table></figure>
​<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2>​</li>
<li>JavaScript 核心篇 (六角學院）</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day14) 閉包 (Closure) 介紹</title>
    <url>/2021/10/02/JS-core/(Day14)%20%E9%96%89%E5%8C%85%20(Closure)%20%E4%BB%8B%E7%B4%B9/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>閉包算是在 JS 中常聽到，卻不容易使用的一個方法，更多狀況是不小心用出來，因此出 bug</p>
<h2 id="閉包與記憶體"><a href="#閉包與記憶體" class="headerlink" title="閉包與記憶體"></a>閉包與記憶體</h2><p>在介紹閉包之前，先來看看下面範例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomString</span>(<span class="params">length</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="keyword">var</span> characters = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#x27;</span>;</span><br><span class="line">      <span class="keyword">var</span> charactersLength = characters.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result += characters.charAt(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * charactersLength));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> demoData = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        demoData.push(randomString(<span class="number">1000</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getData();</span><br></pre></td></tr></table></figure>

<p><code>randomString</code> 是一個會根據設定執行數次，產生亂碼字串的方法，而這亂碼字串會藉由 <code>return result</code> 回傳，最後又在 push 至 demoData 變數上。</p>
<p>使用 chrome 無痕模式來觀察 Memory ，可以發現在執行上述程式碼時，記憶體使用了 1.3 MB<br><img src="https://i.imgur.com/CYNa4it.png"></p>
<p>再來執行另外一段非常相近的程式碼，來看看他的記憶體使用量：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomString</span>(<span class="params">length</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="keyword">var</span> characters = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#x27;</span>;</span><br><span class="line">      <span class="keyword">var</span> charactersLength = characters.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result += characters.charAt(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * charactersLength));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> demoData = [];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        demoData.push(randomString(<span class="number">1000</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getData();</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/xiO1WoI.png" alt="Untitled"></p>
<p>可以發現這個範例記憶體增使用量將近 21MB ，這是因為第二個範例 <code>demoData</code> 變數是被放在外層也就是全域( window)底下，而 <code>demoData</code> 變數此時是能在被呼叫、使用的。</p>
<p>而第一個範例中， <code>demoData</code> 是在函示裡頭， <code>demoData</code> 變數則會跟著 <code>getData</code> 執行完畢時，一同被釋放記憶體，此時 <code>demoData</code>  也是無法被呼叫的，因此兩者記憶體落差十分大。</p>
<p>之所以要先講這一段是因為，記憶體可以說是閉包的一個重點。</p>
<h2 id="閉包範例與解釋"><a href="#閉包範例與解釋" class="headerlink" title="閉包範例與解釋"></a>閉包範例與解釋</h2><p>接下先來看看閉包的一個簡單範例</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> num = <span class="number">10</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">ClosureFn</span>(<span class="params">newNum</span>) </span>&#123;</span><br><span class="line">        num = num + newNum</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//函示內 return 函示就會變成 『閉包』</span></span><br><span class="line">      <span class="keyword">return</span> ClosureFn</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">const</span> useClosure = openFn()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(useClosure(<span class="number">10</span>)) <span class="comment">//20</span></span><br><span class="line"><span class="built_in">console</span>.log(useClosure(<span class="number">10</span>)) <span class="comment">//30</span></span><br><span class="line"><span class="built_in">console</span>.log(useClosure(<span class="number">10</span>)) <span class="comment">//40</span></span><br></pre></td></tr></table></figure>

<p>在上面範例中 <code>ClosureFn</code> 其實就是閉包，若要執行這個閉包可以直接使用 <code>openFn()(100)</code>  其就會被執行，不過一般來說我們不會直接使用兩個 <code>()()</code> 小刮號做執行，而是像上面範例中使用 <code>openFn()</code> 並且再用一個變數來做指向。 </p>
<p>而上面有提到記憶體是閉包的重點，關於這一點我們可以看看連續執行 <code>useClosure()</code>  後回傳的值會不斷疊加，然而 <code>ClosureFn</code> 閉包函示內部雖然沒有  <code>let num = 100</code> ，不過閉包內部會因為 <code>num = num + newNum</code>  這段程式碼，有使用到 <code>num</code> 變數，因此按照作用域的規則，會訪問(參考）外層函式的 <code>let num</code>  變數，因為這個訪問(參考）的動作，就會讓 <code>num</code> 變數的記憶體『不被釋放』，因此當正是因為這個『不被釋放』，我們使用 <code>useClosure(10)</code> 的值才可以不斷被疊加。</p>
<p>這邊也試者使用圖片來增加對閉包的理解：<br><img src="https://i.imgur.com/WVBIaGr.png"><br>之所以要使用閉包，就是因為可以透過不同變數、常數，讓閉包回傳資料各自獨立，某些需要重複使用程式碼的狀況就可以使用閉包，例如</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> num = <span class="number">10</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">ClosureFn</span>(<span class="params">newNum</span>) </span>&#123;</span><br><span class="line">        num = num + newNum</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//函示內 return 函示就會變成 『閉包』</span></span><br><span class="line">      <span class="keyword">return</span> ClosureFn</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">const</span> useClosure1 = openFn()</span><br><span class="line"><span class="built_in">console</span>.log(useClosure1(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">console</span>.log(useClosure1(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">const</span> useClosure2 = openFn()</span><br><span class="line"><span class="built_in">console</span>.log(useClosure2(<span class="number">100</span>))</span><br><span class="line"><span class="built_in">console</span>.log(useClosure2(<span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<p>下篇則會介紹閉包延伸運用。</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ul>
<li>JavaScript 核心篇 (六角學院）</li>
<li><a href="https://hsiangfeng.github.io/javascript/20201220/3559993634/">JavaScript 核心觀念(38)-函式以及 This 的運作-閉包 Closure</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day15) 閉包進階使用，工廠模式及私有方法</title>
    <url>/2021/10/02/JS-core/(Day15)%20%E9%96%89%E5%8C%85%E9%80%B2%E9%9A%8E%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%B7%A5%E5%BB%A0%E6%A8%A1%E5%BC%8F%E5%8F%8A%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E3%80%82/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上回介紹閉包概念以及閉包大致運用，這次則介紹實做比較常用閉包的幾種模式</p>
<h2 id="工廠模式"><a href="#工廠模式" class="headerlink" title="工廠模式"></a>工廠模式</h2><p>上個章節有介紹到，使用不同變數可以讓閉包儲存的記憶體分開，在透過不同參數可以達成需要重複運行，卻需要不同值做呈現、運算的部分，比如下面範例。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">interview</span>(<span class="params">name,office</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	  <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">`我的名字是 <span class="subst">$&#123;name&#125;</span>，我是來應徵 <span class="subst">$&#123;office&#125;</span>`</span>)</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Ryder = interview(<span class="string">&#x27;Ryder&#x27;</span>,<span class="string">&#x27;前端工程師&#x27;</span>)</span><br><span class="line">Ryder() <span class="comment">// 我的名字是Ryder，我是來應徵 前端工程師</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Jason = interview(<span class="string">&#x27;Jason&#x27;</span>,<span class="string">&#x27;專案經理&#x27;</span>)</span><br><span class="line">Jason() <span class="comment">//我的名字是Jason，我是來應徵 專案經理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Emma = interview(<span class="string">&#x27;Emma&#x27;</span>,<span class="string">&#x27;品管工程師&#x27;</span>)</span><br><span class="line">Emma() <span class="comment">//我的名字是 Emma，我是來 品管工程師</span></span><br></pre></td></tr></table></figure>

<h2 id="私有方法-又稱-模組設計模式（module-pattern）"><a href="#私有方法-又稱-模組設計模式（module-pattern）" class="headerlink" title="私有方法 又稱 模組設計模式（module pattern）"></a>私有方法 又稱 模組設計模式（module pattern）</h2><p>上一章節也有提到，最簡單的閉包就是在函示中 <code>return</code>  一個函示，而私有方法 則是 <code>return</code>  出一個物件，再將各種函示包在物件中，這樣就可以呼叫物件中各式不同的方法，以達成實做時的各種需求，並且和工廠模式相同，使用不同變數、常數閉包儲存的記憶體也會不同，因此可以透過不同參數達成各自獨立計算的需求。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buyGame</span>(<span class="params">initValue</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> money = initValue||<span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">buyNS</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      money = money - <span class="number">9000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">buyPS5</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      money = money - <span class="number">15000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">remainMoney</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> money</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Ryder = buyGame(<span class="number">30000</span>)</span><br><span class="line">Ryder.buyNS()</span><br><span class="line">Ryder.buyNS()</span><br><span class="line"><span class="built_in">console</span>.log(Ryder.remainMoney()) <span class="comment">//Ryder 買了兩台 NS 剩 12000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Emma = buyGame(<span class="number">50000</span>)</span><br><span class="line">Emma.buyNS()</span><br><span class="line">Emma.buyPS5()</span><br><span class="line"><span class="built_in">console</span>.log(Emma.remainMoney()) <span class="comment">//Emma 買了一台 NS 一台 PS5 剩下26000</span></span><br></pre></td></tr></table></figure>

<p>P.S 這邊的 <code>buyNS()</code>、  <code>buyPS5()</code> 是使用物件函式縮寫，未縮寫前是 <code>buyNS：fuction()</code> 、 <code>buyPS5: function()</code></p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ul>
<li>JavaScript 核心篇 (六角學院）</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day01) 執行環境與執行堆疊</title>
    <url>/2021/10/01/JS-core/(Day01)%20%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83%E8%88%87%E5%9F%B7%E8%A1%8C%E5%A0%86%E7%96%8A/</url>
    <content><![CDATA[<h2 id="執行環境-Execution-context"><a href="#執行環境-Execution-context" class="headerlink" title="執行環境 (Execution context)"></a>執行環境 (Execution context)</h2><p>​<br>在 JS 世界中執行環境是根據不同 function ，做區分的不同的函示，執行環境會是不同的。<br>​<br>直接用個簡單例子，就可以看出這個觀念：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FN1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> string = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(string)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FN2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(string)</span><br><span class="line">&#125;</span><br><span class="line">FN1() <span class="comment">//test</span></span><br><span class="line">FN2() <span class="comment">//string is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(string) <span class="comment">//string is not defined</span></span><br></pre></td></tr></table></figure>
<p>​<br>如同上面範例中，<code>FN2</code> 函示中、以及全域底下是無法找到 FN1 中的 <code>string</code> 常數，值得一提的是 JS 最底層的執行環境，就是全域本身(window) 。<br>​</p>
<h2 id="執行堆疊-Execution-Stack"><a href="#執行堆疊-Execution-Stack" class="headerlink" title="執行堆疊 (Execution Stack)"></a>執行堆疊 (Execution Stack)</h2><p>​<br>執行堆疊是和上面執行環境相關的觀念，一般狀況下，函示執行完畢，函示記憶體便會釋放，比如這個範例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FN1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;FN1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FN2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;FN2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">FN1()</span><br><span class="line">FN2()</span><br><span class="line">​</span><br></pre></td></tr></table></figure>
<p>​<br>範例的執行順序就會是：<br>執行 FN1 函示 ⇒ FN1 函示執行完畢，釋放記憶體 ⇒ 執行  FN2 函示 ⇒ FN2 函示執行完畢，釋放記憶體 。<br>當然這是一般狀況，如果我們函示中又『呼叫』了另外的函示，那麼就會造成執行堆疊的狀況，比如這個範例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FN1</span>(<span class="params">parmNum</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> number1 = parmNum + <span class="number">1</span></span><br><span class="line">  FN2(number1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FN2</span>(<span class="params">parmNum</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> number2 = parmNum + <span class="number">1</span></span><br><span class="line">    FN3(number2)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FN3</span>(<span class="params">parmNum</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> number3 = parmNum + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">FN1(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>​<br>這邊可以使用 chrome 瀏覽器的 Sources 功能來觀察 執行堆疊 狀況：<br><img src="https://i.imgur.com/UNo8DVC.gif" alt="執行堆疊.gif"><br>(這邊要注意的是圖中的 Call Stack 狀況，Call Stack 就是執行堆疊狀態）<br>​<br>從上面 GIF 可以發現，<code>FN1()</code> 呼叫了 <code>FN2()</code>， 這種函示呼叫另一個函示時，Call Stack 就會一層一層疊起來，而這個堆疊順序是根據 『怎麼呼叫函示』有關，而非函示的宣告順序，因此根據程式碼執行堆疊順序就會是：<br><code>FN1()</code> ⇒ <code>FN2()</code> ⇒ <code>FN3()</code><br>​<br>而上面有提到函示執行完畢，會將記憶體釋放，而堆疊後的函示釋放順序則不會是一般人預期中的：<br><code>FN1()</code> ⇒ <code>FN2()</code> ⇒ <code>FN3()</code><br>​<br>而是由最後被執行的函示開始釋放，因此釋放的順序會是：<br><code>FN3()</code> ⇒  <code>FN2()</code> ⇒ <code>FN1()</code><br>​</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><p>​</p>
<ul>
<li>JavaScript 核心篇 (六角學院）</li>
<li><a href="https://hsiangfeng.github.io/javascript/20200502/2917226562/">JavaScript 核心觀念(4)-執行環境與作用域-執行環境與執行堆疊</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day02) 範圍鍊與提升</title>
    <url>/2021/10/01/JS-core/(Day02)%20%E7%AF%84%E5%9C%8D%E9%8D%8A%E8%88%87%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<h2 id="範圍鍊-Scope-Chain"><a href="#範圍鍊-Scope-Chain" class="headerlink" title="範圍鍊 (Scope Chain)"></a>範圍鍊 (Scope Chain)</h2><p>範圍鍊在 JavaScript 一堆奇奇怪怪的觀念中算是簡單好懂的，簡單來說就是：</p>
<p>『函示內沒有對應的變數、常數或是函示時，他會往外層尋找』</p>
<p> 這邊一樣用程式碼來說明。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">playGame</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> gaming = <span class="string">&#x27;PS5&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我要用 <span class="subst">$&#123;gaming&#125;</span> 玩遊戲`</span>)</span><br><span class="line">&#125;</span><br><span class="line">playGame() <span class="comment">//我要用 PS5 玩遊戲</span></span><br></pre></td></tr></table></figure>

<p>上面這段 <code>gaming</code> 在函示內，因此能正確顯示，<del>這段好像廢話</del>，不過接下來我們試者把 <code>gaming</code> 移到外層全域看看結果如何：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gaming = <span class="string">&#x27;PS5&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">playGame</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我要用 <span class="subst">$&#123;gaming&#125;</span> 玩遊戲`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  playGame() <span class="comment">//我要用 PS5 玩遊戲</span></span><br></pre></td></tr></table></figure>

<p>結果是一樣的，上面 <code>playGame()</code> 函式中因為本身沒有 <code>gaming</code>  常數，因此他會到外層也是全域 (window) ，來獲得 <code>gaming</code>  常數的資料。</p>
<p>接下來便是在函示內外都新增兩個 <code>gaming</code>  來看看結果如何</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gaming = <span class="string">&#x27;PS5&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">playGame</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">const</span> gaming = <span class="string">&#x27;Switch&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我要用 <span class="subst">$&#123;gaming&#125;</span> 玩遊戲`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  playGame() <span class="comment">//我要用 Switch 玩遊戲</span></span><br></pre></td></tr></table></figure>

<p> 所以結果就是當函示內有相關資料時，變不會往外層尋找，而是直接使用函示內資料。</p>
<h2 id="提升-Hoisting"><a href="#提升-Hoisting" class="headerlink" title="提升(Hoisting)"></a>提升(Hoisting)</h2><p>(因為 <code>const</code>、 <code>let</code>  提升的狀況不一樣，這邊範例先改為使用 <code>var</code> ， <code>const</code>、 <code>let</code>  會到介紹他們的章節再來提及)</p>
<p>JavaScript 實際編譯並執行程式碼時，會分為兩種階段:</p>
<ul>
<li>創造階段</li>
<li>執行階段</li>
</ul>
<p>等創造階段執行完畢，才會進入執行階段，創造階段有幾個重點：</p>
<ul>
<li>優先建立函示（執行環境） 但不運行，只是建立環境。</li>
<li>再來建立變數，但不會為變數賦值，只是建立一個空值 (undefined) 的變數。</li>
<li>用言語形容這個階段的話就是一個先建立容器，因為這個創造階段的特性，所以這個狀況被稱做 <strong>Hoisting</strong> (提升)。</li>
</ul>
<p>而執行階段的重點則是：</p>
<ul>
<li>執行 呼叫函式 的 <code>XX()</code> 。</li>
<li>為變數賦予實際的值。</li>
</ul>
<p>這邊使用上面程式碼，並稍微調一下順序就可驗證上面提到的創造階段。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(gaming) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> gaming = <span class="string">&#x27;PS5&#x27;</span></span><br><span class="line">playGame() <span class="comment">//我要用 PS5 玩遊戲</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">playGame</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我要用 <span class="subst">$&#123;gaming&#125;</span> 玩遊戲`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>console.log(gaming)</code>  這段會因為變數被提升，但尚未賦值因此是 cosnole 會回傳 <code>undefined</code></p>
<p><code>playGame()</code>  則是 <code>function playGame()</code> 函示會因為提升效果，而先比被呼叫函示的 <code>playGame()</code>  建立，因此 console 可以正確顯示。</p>
<p>因為提升這個 特性 會讓上面的程式碼，在編譯順序變為:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 創造階段</span></span><br><span class="line"><span class="comment">//函示優先提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">playGame</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我要用 <span class="subst">$&#123;gaming&#125;</span> 玩遊戲`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> gaming </span><br><span class="line"></span><br><span class="line"><span class="comment">// 執行階段</span></span><br><span class="line"><span class="built_in">console</span>.log(gaming) <span class="comment">// undefined</span></span><br><span class="line">gaming = <span class="string">&#x27;PS5&#x27;</span></span><br><span class="line">playGame() <span class="comment">//我要用 PS5 玩遊戲</span></span><br></pre></td></tr></table></figure>

<p>最後要說的是，Hoisting 只是概念，只是幫助我們理解，程式碼在編譯時會這麼做，但他仍只是一種概念， 這點 <a href="https://developer.mozilla.org/zh-TW/docs/Glossary/Hoisting">MDN 文件</a>也有說明到：</p>
<blockquote>
<p>提升（Hoisting）是在 ECMAScript® 2015 Language Specification 裡面找不到的專有名詞。它是一種釐清 JaveScript 在執行階段內文如何運行的思路（尤其是在創建和執行階段）。</p>
</blockquote>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ul>
<li>JavaScript 核心篇 (六角學院）</li>
<li><a href="https://hsiangfeng.github.io/javascript/20200503/1924910570/">JavaScript 核心觀念(6)-執行環境與作用域-提升</a></li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Glossary/Hoisting">MDN 文件(提升)</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day03) 執行緒 與 同步 &amp; 非同步</title>
    <url>/2021/10/01/JS-core/(Day03)%20%E5%9F%B7%E8%A1%8C%E7%B7%92%20%E8%88%87%20%E5%90%8C%E6%AD%A5%20&amp;%20%E9%9D%9E%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h2 id="單執行緒"><a href="#單執行緒" class="headerlink" title="單執行緒"></a>單執行緒</h2><p>JavaScript 是單執行緒的語言，而單執行緒的意思就是一次只做一件事情。</p>
<p>不過這樣的話 單執行緒 的 JavaScript ， 一旦程式碼時遇到卡住的地方 (阻塞)，整個程式碼不就是應該卡住無法使用？</p>
<p>就是為了解決這個問題， JS 中有部分方法是使用非同步來避免這件事。</p>
<h2 id="非同步-Asynchronous"><a href="#非同步-Asynchronous" class="headerlink" title="非同步(Asynchronous)"></a>非同步(Asynchronous)</h2><p>什麼是非同步？</p>
<p>先來說說什麼是同步(Synchronous)，同步的意思就是，當程式碼執行時他一定會依序做完才往下做，例如以下程式碼:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我第一&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我第二&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我第三&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">Fn1() </span><br><span class="line">Fn2() </span><br><span class="line">Fn3() </span><br></pre></td></tr></table></figure>

<p>以上 console 顯示的一定會是按照順序顯示， 我第一 ⇒  我第二 ⇒ 我第三 ，這種會按照順序執行的程式碼部分就被稱做『同步』。</p>
<p>理解好什麼是同步後，非同步自然比較好理解，自然就是同步的反義詞，不會依照順序執行，例如以下程式碼：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我第一&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我第二&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我第三&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">Fn1()</span><br><span class="line">Fn2() </span><br><span class="line">Fn3() </span><br></pre></td></tr></table></figure>

<p>這邊使用 setTimeout() 來模擬非同步語法，可發現顯示出來的順序會是， 我第一 ⇒ 我第三 ⇒ 我第二 ，之所以順序是這樣，是因為 JavaScript 有一個稱做 事件循環（event loop）的特性來處理非同步語法。</p>
<p>JavaScript 中常見的非同步語法有：</p>
<ul>
<li>setTimeout() 及 setInterval() 定時器。 </li>
<li>fetch 、 XMLHttpRequest 等等處理 Ajax 行為的語法。</li>
<li>ES6 新增的 Promise 。</li>
</ul>
<h2 id="事件循環-event-loop"><a href="#事件循環-event-loop" class="headerlink" title="事件循環 (event loop)"></a>事件循環 (event loop)</h2><blockquote>
<p>event loop 的作用是去監控堆疊（call stack）和工作佇列（task queue），當堆疊當中沒有執行項目的時候，便把佇列中的內容拉到堆疊中去執行。</p>
</blockquote>
<p>上面引用 pjchender 大大 文章中提到的一段話，這段話個人認為，確實是最好理解事件循環的一段話，在<a href="https://ithelp.ithome.com.tw/articles/10258979/">(Day1)執行環境與執行堆疊</a>有提到，在函示中呼叫另一個函示會造成堆疊狀況（call stack），雖然稱做堆疊，但這種狀況其實是屬於同步的狀況。</p>
<p>而工作佇列（task queue）則是 JavaScript 這語法專門存放非同步語法的地方。</p>
<p>也就是說 事件循環 特性就是，非同步語法會等待 同步語法 執行完畢接著才被執行，這邊也使用一段程式碼查看這個特性：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;非同步&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(i)</span><br><span class="line">        &#125;)()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>

<p>呼叫 <code>test()</code>  這個函示會在 console 依序顯示 1、2、3 …10 。<br>運行上面範例會是先顯示完 1、2、3 …10 ，最後才顯示 <strong>非同步</strong> 的字串，如果你覺得你的電腦夠好，也可以試者把  <code>for</code>  迴圈改成執行 10 萬次，結果也會是<strong>非同步</strong>字串最後才顯示。</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ul>
<li>JavaScript 核心篇 (六角學院）</li>
<li><a href="https://hsiangfeng.github.io/javascript/20200531/3571534372/">JavaScript 核心觀念(9)-執行環境與作用域-執行緒與同步、非同步</a></li>
<li><a href="https://pjchender.dev/javascript/js-event-loop-stack-queue/">[JS] 理解 JavaScript 中的事件循環、堆疊、佇列和併發模式（Learn event loop, stack, queue, and concurrency mode of JavaScript in depth）</a></li>
<li><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ&t=385s&ab_channel=JSConf">所以說 event loop 到底是什麼玩意兒？| Philip Roberts | JSConf EU</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day04) 陳述式 &amp; 表達式</title>
    <url>/2021/10/01/JS-core/(Day04)%20%E9%99%B3%E8%BF%B0%E5%BC%8F&amp;%E8%A1%A8%E9%81%94%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript 的語句分成兩種 陳述式、表達式，這兩種語法區分並不困難，接下來會一一介紹，比較特別的是函示也會分為兩種： 函示陳述式、 函示表達式 ，這兩種函示在『提升』特性上會有所差別，最後也會介紹到。<br>​</p>
<h2 id="陳述式-Statement"><a href="#陳述式-Statement" class="headerlink" title="陳述式 (Statement)"></a>陳述式 (Statement)</h2><p>​<br>陳述式的特色是執行程式碼操作，但『不會回傳任何值』。<br>​<br>常見的陳述式有：<br>​</p>
<ul>
<li>建立變數的 <code>var</code>、 <code>let</code>、 <code>const</code></li>
<li>判斷用的 <code>if...else</code> 、<code>switch</code> ，</li>
<li>建立函示的 <code>function</code> (建立但不是呼叫）</li>
<li><code>for</code> 迴圈 …等等</li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements">MDN 文件</a> 有列出完整的，哪些語法是陳述式</li>
</ul>
<p>這時想必就會有人想問，我們在瀏覽器建立任意變數時，他都會回傳 <code>undefined</code>，那麼為什麼建立變數不是表達式？<br>​<br>這是因為瀏覽器在建立變數時，會需要替變數製作一個記憶體空間，而回傳的這個 <code>undefined</code> 則是告訴使用者已經為這個變數，建立好對應的記憶空間，而非真正的回傳一個值。<br><img src="https://s3-us-west-2.amazonaws.com/video-hexschool/teachable/XzTrVKrzlXIMoWlK8wubEq8ELl9gOvHBg8OFVEML2ahREJjyTzkZZLWHYZ9ZVmnQFOXqknDVDsNWtAiZMR0WdqQv1p7xP3ibeDPTKHlZ5wr0Qn5jvgoil2S7sGIIF3OH." alt="Untitled"><br>​<br>​</p>
<h2 id="表達式-Expreesion"><a href="#表達式-Expreesion" class="headerlink" title="表達式 (Expreesion)"></a>表達式 (Expreesion)</h2><p>​<br>又稱運算式，執行表達式時，表達式會『回傳值』<br>​<br><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E9%81%8B%E7%AE%97%E5%BC%8F">MDN 文件</a> 同樣也有提到表達式的種類。<br>​<br>在上面有提到在瀏覽器建立變數時， 會回傳 <code>undefined</code>  ，這點其實在其他『陳述式』上也會發生，例如<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i; i&lt;<span class="number">10</span> ; i++)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>​<br>上述陳述式在執行時都會回傳  <code>undefined</code><br><img src="https://s3-us-west-2.amazonaws.com/video-hexschool/teachable/8xqJ74r2gANtqfSqIUaP5lyr0GHc8OFxZpq2viOCJG2uGphhYgrx2eJDoqVSMoRYAtnQgH87JI2H93xjdLFwMpRZ8BCfYw6rOqoJ8liQycgpgQ67McSIxj3bTTE47oV5." alt="undefined2"><br>但是這些都不是真正的回傳值，而是跟變數一樣，是瀏覽器告訴使用者，已經為了這段程式碼建立好對應記憶體空間，而真正的表達式則是一定會回傳『值』，例如：<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">1</span></span><br><span class="line">array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">array ===  <span class="literal">true</span></span><br><span class="line">​</span><br></pre></td></tr></table></figure>
<p>​<br><img src="https://s3-us-west-2.amazonaws.com/video-hexschool/teachable/JrZAbIbbG1sj2UN8AfrEuWBvP9IIK04c9ytX6xhc8be53v01nIqnofjTrCwMNvnReRc5arh42pZkhQl34jR6f3S6DOUjeQJ13nzz0n63ZgteBULpRF85nXIC6n2f5iPA." alt="Untitled"><br>​</p>
<h2 id="函示陳述式"><a href="#函示陳述式" class="headerlink" title="函示陳述式"></a>函示陳述式</h2><p>​<br>函示根據建立方法分成：函示陳述式、函示表達式 兩種。<br>函示陳述式就是我們常使用的 <code>function xxx()</code>  由於這種函示帶有自己的名稱，因此又被稱做具名函示，例如：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;函示陳述式、又稱具名函示&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<h2 id="函示表達式"><a href="#函示表達式" class="headerlink" title="函示表達式"></a>函示表達式</h2><p>​<br>函式表達式會使用一個變數搭配等號運算子，以及一個函示。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;函示表達式、又稱匿名函示&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​<br>兩者主要差別在之前提到的『提升』不同，函示陳述式因為提升效果關係，呼叫函示的 <code>xx()</code>  可以在函示上方<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">test1() <span class="comment">//函示陳述式、又稱具名函示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;函示陳述式、又稱具名函示&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​<br>而函示表達式則不行，根據提升效果 變數 雖然會在創造階段被創造出來，但實際上他是沒有值的狀態，因此將 呼叫函示的 <code>xx()</code>  擺在函示表達式上方，是會跳出錯誤訊息。<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">test2() <span class="comment">//test2 is not a function</span></span><br><span class="line"><span class="keyword">var</span> test2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;函示表達式、又稱匿名函示&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>​<br>​</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><p>​</p>
<ul>
<li>JavaScript 核心篇 (六角學院）</li>
<li><a href="https://hsiangfeng.github.io/javascript/20200607/196651152/">JavaScript 核心觀念(11)-運算子、型別與文法-陳述式與表達式</a></li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements">MDN 文件 - 陳述式與宣告</a></li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E9%81%8B%E7%AE%97%E5%BC%8F">MDN 文件 - 運算式與運算子</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day07) 隱含轉型-偷偷轉換的 Strings 與 Numbers 類型</title>
    <url>/2021/10/02/JS-core/(Day07)%20%E9%9A%B1%E5%90%AB%E8%BD%89%E5%9E%8B-%E5%81%B7%E5%81%B7%E8%BD%89%E6%8F%9B%E7%9A%84%20Strings%20%E8%88%87%20Numbers%20%E9%A1%9E%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天介紹了 JS 中強制轉型，顯性轉型的部分，今天就要介紹最坑人的隱含轉型</p>
<p> 這邊同樣將隱含轉型做個大方向的分類：</p>
<ul>
<li>隱含轉型 : Strings &lt;–&gt; Numbers</li>
<li>隱含轉型 : 轉成 Boolean</li>
<li>邏輯算子 || 與 &amp;&amp;</li>
<li>寬鬆相等（Loose Equals） vs 嚴格相等（Strict Equals）<br>今天則會先介紹 隱含轉型 : Strings &lt;–&gt; Numbers 的部分，剩餘的隱含轉型則會再下一篇介紹。</li>
</ul>
<h2 id="隱含轉型-Strings-lt-–-gt-Numbers"><a href="#隱含轉型-Strings-lt-–-gt-Numbers" class="headerlink" title="隱含轉型 : Strings &lt;–&gt; Numbers"></a>隱含轉型 : Strings &lt;–&gt; Numbers</h2><p>在<a href="https://ithelp.ithome.com.tw/articles/10260887">上篇顯性轉型</a>文章中，有刻意將 Strings &lt;–&gt; Numbers 拆成轉成字串、轉成數字，不過在隱含轉型中由於  <code>+</code> 號算數運算子狀況過於特別，所以這次還是一起講了。</p>
<h3 id="狀況一-算數運算子"><a href="#狀況一-算數運算子" class="headerlink" title="狀況一 + 算數運算子"></a>狀況一 <code>+</code> 算數運算子</h3><p>我們都知道，使用 <code>+</code> 運算子，相加兩個數字時，呈現結果會是兩個數字總和，若用  <code>+</code> 將兩組字串相加，則會讓字串內容連起來，但如果兩個運算元的型別不一致呢？</p>
<p>這種狀況 JS 會根據 運算元中是否有字串、數字類型時，將另為一個運算元自動轉型，關於這部分則有幾個規則：</p>
<ul>
<li>當雙方有一方是字串，兩者都會轉字串（優先度最高<ul>
<li><code>[]</code> 碰上 <code>+</code> 號，陣列中的值會一併轉成字串，並帶上陣列中的逗號，若是空陣列則轉成空字串。</li>
<li><code>&#123;&#125;</code> 放在運算元第一位，碰上 <code>+</code>  號，<code>&#123;&#125;</code>  會直接被當成空區塊而無作用，若 <code>&#123;&#125;</code>  放在運算元第二位或是後方時，會被轉成 <code>&quot;[object Object]&quot;</code> 的字串，且上述規則不論物件是否有值都會成立。</li>
</ul>
</li>
<li>當雙方有數字，兩者會轉數字（次等</li>
</ul>
<p>接著就用程式碼來看看上面規則是否正確:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;test&#x27;</span> + <span class="number">1</span> <span class="comment">//&quot;test1&quot; </span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>&#39;test&#39;</code> 是字串，數字 1 被轉成字串，字串相加。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span> + [] <span class="comment">// &quot;123&quot; </span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>[]</code> 會轉成空字串，因此數字 123 也轉成字串，結果就是字串 “123”</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>] + <span class="number">456</span> <span class="comment">//&quot;1,2,3456&quot; </span></span><br></pre></td></tr></table></figure>
<ul>
<li>陣列中的值會轉成字串，數字 456 因此被轉成字串，字串相加，要注意的是陣列轉成字串後 <code>,</code> 會被保留。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;&#125; + <span class="string">&#x27;123&#x27;</span> <span class="comment">//123 </span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>&#123;&#125;</code> 在前沒有作用，會變成 <code>+</code> 號會變成正負運算子，因為正負運算子字串 <code>&#39;123&#39;</code>  會被轉成數字。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">666</span> + &#123;<span class="attr">obj</span>:<span class="string">&#x27;test&#x27;</span>&#125; <span class="comment">//&quot;666[object Object]&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>&#123;obj:&#39;test&#39;&#125;</code>  在後面 會被轉型成 <code>&quot;[object Object]&quot;</code> 的字串，因此數字 666 也轉成字串 “666” 做字串相加。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span> + <span class="number">10</span> <span class="comment">//11</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>true</code> 轉成數字 1 ，與數字 10 相加。</li>
</ul>
<p>以上大致就是各種型別碰上 <code>+</code> 算數運算子隱含轉後的狀況。</p>
<h3 id="狀況二-使用算數運算子將字串轉為數字"><a href="#狀況二-使用算數運算子將字串轉為數字" class="headerlink" title="狀況二 使用算數運算子將字串轉為數字"></a>狀況二 使用算數運算子將字串轉為數字</h3><p>除了 <code>+</code>  算數運算子，的狀況比較特別，其他算數運算子，都會將字串轉換成數字，範例如下</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="string">&#x27;2&#x27;</span></span><br><span class="line">test + <span class="number">1</span>  <span class="comment">//&quot;21&quot;</span></span><br><span class="line">test - <span class="number">1</span>  <span class="comment">// 1</span></span><br><span class="line">test * <span class="number">1</span>  <span class="comment">//2</span></span><br><span class="line">test / <span class="number">1</span> <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>但如果字串不是數字內容的字串，使用 <code>+</code> 以外的算數運算子時都會回傳 <code>NaN</code> ，例如：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="string">&#x27;test&#x27;</span></span><br><span class="line">test - <span class="number">1</span>  <span class="comment">// NaN</span></span><br><span class="line">test * <span class="number">1</span>  <span class="comment">// NaN</span></span><br><span class="line">test / <span class="number">1</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li>JavaScript 核心篇 (六角學院）</li>
<li><a href="https://cythilya.github.io/2018/10/15/coercion/#tonumber">你懂 JavaScript 嗎？#8 強制轉型（Coercion）</a></li>
<li><a href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/types%20%26%20grammar/ch4.md">你不懂 JS：类型与文法</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day08) 隱含轉型 - 轉成 Boolean &amp; 寬鬆相等 vs 嚴格相等</title>
    <url>/2021/10/02/JS-core/(Day08)%20%E9%9A%B1%E5%90%AB%E8%BD%89%E5%9E%8B%20-%20%E8%BD%89%E6%88%90%20Boolean%20&amp;%20%E5%AF%AC%E9%AC%86%E7%9B%B8%E7%AD%89%20vs%20%E5%9A%B4%E6%A0%BC%E7%9B%B8%E7%AD%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇介紹了數字型別、字串型別的隱含轉型，接下來介紹剩餘的隱含轉行，剩餘隱含轉型大約分成以下三種：</p>
<ul>
<li>隱含轉型 : 轉成 Boolean</li>
<li>運算子 || 與 &amp;&amp;</li>
<li>寬鬆相等（Loose Equals） vs 嚴格相等（Strict Equals）</li>
</ul>
<h2 id="隱含轉型-轉成-Boolean"><a href="#隱含轉型-轉成-Boolean" class="headerlink" title="隱含轉型 : 轉成 Boolean"></a>隱含轉型 : 轉成 Boolean</h2><p>關於轉成布林值這一塊，其實大多都是用在判斷式的條件判斷中，當條件判斷成立，條件判斷會透過隱含轉型轉成 <code>true</code> 因此條件下的程式碼才能被執行， 例如：</p>
<ul>
<li><code>if()</code> 中的條件判斷。</li>
<li><code>for( xx; xx; xx; )</code>  中，第二句的條件判斷。</li>
<li><code>while()</code>  中的條件判斷。</li>
<li><code>xx ? OO1 : OO2</code> 三元運算中的第一個條件判斷。</li>
<li>邏輯運算子中  <code>||</code> 和 <code>&amp;&amp;</code>  最左邊的操作，會被轉換。</li>
</ul>
<p>接下來同樣用程式碼來看看</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">666</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="keyword">var</span> c  </span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">null</span></span><br><span class="line"><span class="keyword">if</span> (a) &#123; </span><br><span class="line">	<span class="comment">// true</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;執行成功&#x27;</span>);		<span class="comment">// 執行成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (c) &#123; </span><br><span class="line">	<span class="comment">// false</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;不執行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d ? a : b <span class="comment">// &#x27;test&#x27; </span></span><br><span class="line"><span class="comment">// d 被轉成 false ，因此執行 b </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((a &amp;&amp; d) || c) &#123;</span><br><span class="line">	<span class="comment">//fasle</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;不執行&#x27;</span>);		</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>上面比較特別的就是 邏輯運算子 <code>||</code> 與 <code>&amp;&amp;</code>  這部分接下來會再說明。</p>
<h2 id="邏輯運算子-與-amp-amp"><a href="#邏輯運算子-與-amp-amp" class="headerlink" title="邏輯運算子 || 與 &amp;&amp;"></a>邏輯運算子 || 與 &amp;&amp;</h2><p>實做中我們很常用到判斷式搭配 <code>||</code> 與 <code>&amp;&amp;</code>  ，例如</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> width = <span class="number">768</span> </span><br><span class="line"><span class="keyword">var</span> fontSize = <span class="number">16</span></span><br><span class="line"><span class="keyword">if</span>( width &gt;= <span class="number">1200</span> || fontSize === <span class="number">16</span> )&#123;</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這會讓我們有種錯覺 <code>||</code>、 <code>&amp;&amp;</code>  運算子就是用來判斷 <code>true</code>、 <code>false</code> 的方法，然而我們在上面 『隱含轉型 : 轉成 Boolean 』這部分就有提到， <code>if()</code> 中的判斷式會被 JavaScript 根據是否達成，轉成 <code>true</code> 、 <code>false</code> ， 也因此 <code>||</code>、 <code>&amp;&amp;</code>  運算子不是單純判斷 <code>true</code> 、 <code>false</code> 的方法，而這兩個運算子語法的功能實際上是 ： 在前後運算元中選擇一個使用，這邊也使用程式碼當作範例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">a || b;		<span class="comment">// 123</span></span><br><span class="line">a &amp;&amp; b;		<span class="comment">// &quot;test&quot;</span></span><br><span class="line"></span><br><span class="line">c || b;		<span class="comment">// &quot;test&quot;</span></span><br><span class="line">c &amp;&amp; b;		<span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>根據 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E9%82%8F%E8%BC%AF%E9%81%8B%E7%AE%97%E5%AD%90">MDN 文件</a>描述：</p>
<p> <code>&amp;&amp;</code> 的狀況是當第一個操作 是 <code>false</code> 時，<code>&amp;&amp;</code> 會回傳第一個運算子，反之第一個是 <code>true</code>  回傳第二個運算子，因此在判斷式中使用 <code>&amp;&amp;</code>  是必須兩個條件都是 <code>true</code>  判斷式才會被執行。</p>
<p> <code>||</code> 運算子正好相反，當第一個操作 是 <code>false</code> 時 <code>||</code> 會回傳第二個運算子，反之第一個是 <code>true</code> 時，<code>||</code> 便會回傳第一個操作結果，因此在判斷式中使用 <code>||</code>  指要一個條件達成 <code>true</code> ，判斷式就會被執行。</p>
<h2 id="寬鬆相等（Loose-Equals）-vs-嚴格相等（Strict-Equals）"><a href="#寬鬆相等（Loose-Equals）-vs-嚴格相等（Strict-Equals）" class="headerlink" title="寬鬆相等（Loose Equals） vs 嚴格相等（Strict Equals）"></a>寬鬆相等（Loose Equals） vs 嚴格相等（Strict Equals）</h2><p>在 JavaScript 中使用 <code>===</code> 比較運算子，我們稱做 嚴格相等（Strict Equals），使用這種方法做對比並不會執行隱含轉型的動作。</p>
<p>而使用 <code>==</code> 比較運算子做對比，稱做 寬鬆相等（Loose Equals），使用這種方法做對比則會執行 隱含轉型 的動作，比如這個範例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;123&#x27;</span> == <span class="number">123</span> <span class="comment">//true  字串 123 會被隱含轉型 </span></span><br><span class="line"><span class="string">&#x27;123&#x27;</span> === <span class="number">123</span> <span class="comment">//false  兩者型別不同</span></span><br></pre></td></tr></table></figure>

<p>那麼關於 <code>==</code>  運算子在轉型上是否有什麼規則？</p>
<p>這邊可以透過 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Equality_comparisons_and_sameness#%E4%B8%80%E8%88%AC%E7%9B%B8%E7%AD%89%EF%BC%88%EF%BC%89">MDN 的文件</a>來了解其規則</p>
<p><img src="https://i.imgur.com/CIBh2jS.png" alt="寬鬆相等"></p>
<p>接者同樣使用程式碼當作範例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="string">&#x27;true&#x27;</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>從上面圖表會發現，字串對上數字是 <code>ToNumber(A) === B</code>  ，也就是兩者都會轉換成數字型別做對比。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] == <span class="string">&#x27;1,2,3&#x27;</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>陣列屬於物件的一種，按照圖表會是 <code>ToPrimitive(A) == B</code>  ，按照 MDN 文件說明</p>
<blockquote>
<p>ToPrimitive(A) 嘗試從物件轉換成原生值，透過嘗試對 A 使用 A.toString 和 A.valueOf 方法。</p>
</blockquote>
<p>也就是 <code>[1,2,3]</code> 會被 <code>toString()</code> 轉成字串 。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span> == <span class="string">&#x27;0&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>布林對字串會是 <code>ToNumber(A) === ToNumber(B)</code> 兩者都會被成數字，結果都是 0 。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span> == <span class="string">&#x27;true&#x27;</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>同上布林對字串會是 <code>ToNumber(A) === ToNumber(B)</code> ，字串 <code>&#39;true&#39;</code> 也會被 <code>ToNumber()</code>  轉換，轉換後是 <code>NaN</code> 。</p>
<p>最後關於寬鬆相等，網路上也有人整理滿完整的圖表，這邊也分享一下：<br><a href="https://thomas-yang.me/projects/oh-my-dear-js/">https://thomas-yang.me/projects/oh-my-dear-js/</a></p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li>JavaScript 核心篇 (六角學院）</li>
<li><a href="https://cythilya.github.io/2018/10/15/coercion/#tonumber">你懂 JavaScript 嗎？#8 強制轉型（Coercion）</a></li>
<li><a href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/types%20%26%20grammar/ch4.md">你不懂 JS：类型与文法</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day09) 運算子中的優先性及相依性</title>
    <url>/2021/10/02/JS-core/(Day09)%20%E9%81%8B%E7%AE%97%E5%AD%90%E4%B8%AD%E7%9A%84%E5%84%AA%E5%85%88%E6%80%A7%E5%8F%8A%E7%9B%B8%E4%BE%9D%E6%80%A7/</url>
    <content><![CDATA[<h2 id="運算子優先性-Precedence"><a href="#運算子優先性-Precedence" class="headerlink" title="運算子優先性 (Precedence)"></a>運算子優先性 (Precedence)</h2><p>先來看一個範例</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> / <span class="number">2</span> * <span class="number">2</span> + <span class="number">2</span> <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<p>這段程式碼執行下來答案是 6 ，很符合我們對數學先乘除後加減的概念。</p>
<p>但在 JavaScript 中還有其他運算子，扣掉我們較熟悉的算數使用的算數運算子，如何知道其他運算子的使用順序呢？</p>
<p>在 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#%E8%A1%A8%E6%A0%BC(table)">MDN 文件</a>中就有提供相關的表格。</p>
<p>在文件中我們可以看到 <code>+</code> 號算數運算子優先性是 13 ，<code>*</code> 跟 <code>/</code> 除，是 14 ，因此也會是我們熟知的先乘除後加減，但 JS 是怎麼判斷範例中先 <code>/</code> 後 <code>*</code> 呢？</p>
<h2 id="運算子相依性-Associativity"><a href="#運算子相依性-Associativity" class="headerlink" title="運算子相依性 (Associativity)"></a>運算子相依性 (Associativity)</h2><p>這時就要介紹運算子另一個特性，『相依性』，而相依性的特性就是，如果運算子是相同優先性，那麼 JavaScript 會根據設定，從指定方向開始執行，從文件上也可以看到 <code>*</code> 跟 <code>/</code>  的算數運算子是 『從左至右』。</p>
<p>再來看看一個滿常見的前端面試問題：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt; <span class="number">2</span> &lt; <span class="number">3</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>答案是 <code>true</code> 跟我理解一般理解的一樣，那麼稍微調整一下順序：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> &gt; <span class="number">2</span> &gt; <span class="number">1</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p> 這時就變成 false 了，這是因為相依性的特性，會讓上面範例在執行整段程式碼是分開的，會先執行　<code>3　&gt;　2</code>  接者才會執行  <code>2　&gt;　1</code>。<br>但上面的說法其實不太正確， <code>3 &gt; 2</code>  這段是表達式，而表達式的特性就是會回傳值。<br><code>3　&gt;　2</code>  這段表達式回傳的會是 <code>true</code> ，因此實際上會是 <code>true &gt; 1</code> ，而不是我們原先認為的 <code>2 &gt; 1</code> 。<br>所以上面這一段在 JavaScript 中是這樣的：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> &gt; <span class="number">2</span> </span><br><span class="line"><span class="literal">true</span> &gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>( true 會隱含轉型變成 1 ， <code>1&gt;1</code> 因此最後回傳 <code>false</code> )</p>
<p>再來根據表達式特性再提一個賦值狀況:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">a = b = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>結果我們查詢 a 、 b 值都會是 3<br>在我們看來會是他的執行順序會是:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">b = <span class="number">3</span>;</span><br><span class="line">a = b</span><br></pre></td></tr></table></figure>

<p>但要注意這個執行順序並不正確，這邊實際上的情況是：</p>
<p><code>b = 1</code> 時，因為這段是表達式，所以會回傳 <code>1</code> ，接者才是 <code>a</code> 被賦予回傳的 <code>1</code><br>所以 <code>a</code> 被賦予的實際上是 <code>b = 1</code> 回傳的值。</p>
<p>我們可以使用 <code>Object.defineProperty()</code> 鎖定物件屬性中的值 來驗證這個觀念：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;test&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>這個寫法會綁定物件 <code>obj</code> 中 <code>test</code> 屬性的值，接者新增一個變數來替換 <code>obj</code> 中的 <code>test</code>:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;test&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line">obj.test = num</span><br><span class="line">obj.test <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p>確認 <code>obj.test</code> 是無法被更改的，接著使用連續賦值的動作看看結果如何:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;test&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line">num = obj.test = <span class="number">5566</span></span><br><span class="line"><span class="built_in">console</span>.log(num,obj.test) <span class="comment">// ???</span></span><br></pre></td></tr></table></figure>
<p>結果回傳的是 <code>5566</code> 和 <code>0</code>，這是因為 <code>5566</code> 雖然沒有成功賦予到 <code>obj.test</code> 上，但是 <code>obj.test = 5566</code> 這段表達式會回傳 <code>5566</code>，因此 <code>num</code> 最後是獲得這個回傳的 <code>5566</code> 。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li>JavaScript 核心篇 (六角學院）</li>
<li><a href="https://hsiangfeng.github.io/javascript/20200628/713590185/">JavaScript 核心觀念(16)-運算子、型別與文法-優先性及相依性</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day-16) this 介紹上 - this 的指向</title>
    <url>/2021/10/03/JS-core/(Day16)%20this%20%E4%BB%8B%E7%B4%B9%E4%B8%8A%20-%20this%20%E7%9A%84%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​<br>不論是學習或是開發時，我們容易被 this 的指向搞的頭昏眼花，接下來會花兩個篇幅介紹 this 指向。<br>​<br>也因為 this 容易把人搞亂這邊先列出影響 this 指向的方法：<br>​</p>
<ul>
<li>簡易呼叫 ( simple call)</li>
<li>物件函式呼叫</li>
<li>addEventListener() 監聽事件觸發的函式</li>
<li>bind ﹑apply 、 call 綁定方法</li>
<li>嚴格模式</li>
<li>new 建構式</li>
<li>箭頭函式<br>​<br>本章節會先介紹上面 簡易呼叫、物件函式呼叫 ，addEventListener() 監聽事件觸發的函式這三個。<br>​<br>bind ﹑apply 、 call 綁定方法、嚴格模式 下篇則會說明這兩組狀況，剩餘的 new 建構式 、箭頭函式 則會到他們各自章節介紹。<br>​<h2 id="簡易呼叫-simple-call"><a href="#簡易呼叫-simple-call" class="headerlink" title="簡易呼叫 ( simple call)"></a>簡易呼叫 ( simple call)</h2>​<br>先來看看指向全域的(window) 的 this 寫法:<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) </span><br><span class="line">&#125;</span><br><span class="line">showName()</span><br></pre></td></tr></table></figure>
​<br>這邊直接使用  <code>showName()</code>  這種直接呼叫函式的方法，這種直接呼叫函式的方法我們稱做 簡易呼叫 ，只要是由簡易呼叫觸發的函式，他當中的 <code>this</code> 一律指向 <code>window</code> 。<br>​<br>可以看到範例中確實會顯示 <code>Ryder</code>  ，其實範例中 <code>this</code> 指向的是 <code>window</code> 。<br>​<br>順帶一題我們常用的 <code>forEach()</code> 、  <code>filter()</code>  中的 callback function ，他也是屬於 簡易呼叫 ，例如：<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) <span class="comment">// Ryder * 3</span></span><br><span class="line">&#125;)</span><br><span class="line">​</span><br><span class="line">array.filter(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) <span class="comment">// Ryder * 3</span></span><br><span class="line">&#125;)</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">​</span><br></pre></td></tr></table></figure>
<h2 id="物件函式呼叫"><a href="#物件函式呼叫" class="headerlink" title="物件函式呼叫"></a>物件函式呼叫</h2>​<br>再來看看 <code>this</code> 指向物件的寫法：<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Ryder&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">showName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) <span class="comment">// Jack</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.showName()</span><br></pre></td></tr></table></figure>
​<br>這個範例中 this 指向的是 <code>obj</code> 這個物件本身，關於物件函式的 <code>this</code> 指向有一個小撇步， this 指向的位置就是，呼叫函式 <code>xxx()</code> 的上一層物件 ，如圖：<br>​<br><img src="https://i.imgur.com/3CjzoGq.png"><br>​<br>在使用另一個多層物件來看看結果是否一致<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Ryder&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">  <span class="attr">obj2</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">showName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) <span class="comment">//Alice</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj1.obj2.showName()</span><br></pre></td></tr></table></figure>
​<br>在根據小撇步 <code>this</code> 會是 <code>showName()</code> 的上一層物件，圖片就會是<br><img src="https://i.imgur.com/zpuw313.png"><br>​<br>​<br>而答案也是正確的，範例中的 <code>this</code> 指向的會是 <code>obj2</code>  ，因此這個範例顯示 <code>&#39;Alice&#39;</code><br>​<h2 id="addEventListener-監聽事件觸發的函式"><a href="#addEventListener-監聽事件觸發的函式" class="headerlink" title="addEventListener() 監聽事件觸發的函式"></a>addEventListener() 監聽事件觸發的函式</h2>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// DOM</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> box = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.box&#x27;</span>)</span><br><span class="line">box.addEventListener(<span class="string">&#x27;click&#x27;</span>, eventFn)</span><br></pre></td></tr></table></figure>
​<br>當我們使用 <code>addEventListener</code> 配合 <code>click</code> 、<code>mouseover</code>  等等事件觸發的函式，他裡面的 <code>this</code>  會是指向觸發事件的 DOM 本身，比如這個範例的點擊 box 時， <code>this</code>  就會是 <code>class=&quot;box&quot;</code> 的 DOM 元素：<br>​<br><img src="https://i.imgur.com/3TugNpj.png"><br>​<br>但要注意的是，這個 DOM 指向是 <code>addEventListener()</code> 特有的， 我們如果改成早期的  <code>onclick</code> 寫法，則又會發現 this 指向的是 <code>window</code> (全域） 。<br>​<br>這個範例，完整程式碼可以參考 codepen :<a href="https://codepen.io/rider159159/pen/JjJrgjK">https://codepen.io/rider159159/pen/JjJrgjK</a><br>​<h2 id="延伸範例"><a href="#延伸範例" class="headerlink" title="延伸範例"></a>延伸範例</h2>​<br>看到這裡你可能會想說 <code>this</code>  的指向好像並不困難，上述都是建立在程式碼拆開來說的情況，接下來就以上面觀念，舉出一些容易讓人覺的混亂例子，並且在一一說明。<br>​<br>範例一：<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span> :<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">showName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    name = <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">var</span> a = obj.showName</span><br><span class="line">a() </span><br></pre></td></tr></table></figure>
​<br>結果會是 <code>Alice</code> 這是因為 <code>obj.showName</code>  賦值給變數 <code>a</code>  時，並沒有使用 <code>()</code> 呼叫 ，因此是將  <code>showName</code>  這個函式的整個內容，賦值到  <code>a</code>  變數上，接者呼叫 <code>a()</code> 來執行原本是 <code>showName</code> 函式中的語法，因此這邊 <code>a()</code> 是 簡易呼叫，所以 <code>this</code>  會指向 <code>window</code> 。<br>​<br>但是一執行  <code>a()</code> ，函式中 <code>name = &#39;Alice&#39;</code>  這段語法就會將全域 <code>name</code> 的值替換成 <code>Alice</code> ，可以在瀏覽器打上 <code>name</code>  來查看全域的 <code>name</code>  是否被替換。<br>​<br>範例二：<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">showName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    name = <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">var</span> a = obj.showName()</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
​<br>這個結果就會是 Jack ，雖然有把 <code>obj.showName()</code> 賦值到變數 a ，但這邊還是由 <code>obj.showName()</code>  來呼叫 <code>showName()</code>  函式，因此這個函式的狀況仍然如下圖，自然 this 的指向就會是 <code>obj</code><br><img src="https://i.imgur.com/su4rccp.png"><br>​<br>範例三：<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">  array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.box&#x27;</span>)</span><br><span class="line">box.addEventListener(<span class="string">&#x27;click&#x27;</span>, eventFn)</span><br></pre></td></tr></table></figure>
​<br>點擊 box 時會顯示？<br>​<br>結果會是顯示三次的  <code>Ryder</code> ，雖然 <code>eventFn</code> 是由事件觸發，但 <code>this</code> 所在的 <code>funciotn</code> 是 <code>forEach</code> 的 callback function ，而 callback function  也是屬於簡易呼叫的一種，因此 <code>this</code> 指向的是 window ，所以顯示全域的 <code>Ryder</code> 。<br>​<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2></li>
<li>JavaScript 核心篇 (六角學院）<br>​</li>
<li><a href="https://hsiangfeng.github.io/javascript/20210403/2190440925/">或許我從一開始就沒有很懂  this</a><br>​</li>
<li><a href="https://hsiangfeng.github.io/javascript/20190418/1842588803/">關於this是一個很神奇的東西這件事情</a> </li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day17) this 介紹下 - 綁定 this  的 call/apply/bind 與嚴格模式</title>
    <url>/2021/10/03/JS-core/(Day17)%20this%20%E4%BB%8B%E7%B4%B9%E4%B8%8B%20-%20%E7%B6%81%E5%AE%9A%20this%20%20%E7%9A%84%20call%20&amp;%20apply%20&amp;%20bind%20%E8%88%87%E5%9A%B4%E6%A0%BC%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇大致講解了 this 在不同狀況的指向，這篇會來講講使用 call/apply/bind 來綁定 this， 以及在嚴格模式下 this 指向會有所不同。</p>
<h2 id="綁定-this-的-call-apply-bind"><a href="#綁定-this-的-call-apply-bind" class="headerlink" title="綁定 this  的 call/apply/bind"></a>綁定 this  的 call/apply/bind</h2><p>當我們遇上某些需求，要求 XX 函式中的 <code>this</code> 是某個特定物件，這時便會使用  <code>call()</code>、 <code>apply()</code> 、<code>bind()</code>  來調整特性函式中的  <code>this</code> 。</p>
<p>這三個方法和 <code>filter()</code> 、 <code>forEach()</code> 一樣是藉由原型提供的，因此這三個方法，不需要任何設定便可使用，這邊先來看看範例</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) </span><br><span class="line">&#125;</span><br><span class="line">showName()</span><br></pre></td></tr></table></figure>

<p>這是上一篇文章中 this 指向 window 的一個範例，這邊試者使用 <code>call()</code> 方法，並且將一個新增的物件當作參數傳入，如：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span> : <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params">item1,item2,item3</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name,item1,item2,item3) <span class="comment">// Jack, test, &#123;&#125;, [0,1,2]</span></span><br><span class="line">&#125;</span><br><span class="line">showName.call(obj,<span class="string">&#x27;test&#x27;</span>, &#123;&#125;, [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p>結果 <code>showName</code> 中的 <code>this</code> 會變成指向 <code>obj</code>  要注意的是使用 <code>showName.call(obj)</code>  他會立刻就回傳，這是因為  <code>call()</code> 這個方法是使用後，會立刻執行函式，並且修正函式中的 <code>this</code> ，順帶一題在 <code>call()</code> 第一個參數是用來綁定函式中 <code>this</code> 的，第一個參數後面的參數，則都是傳遞給原本函示的參數。</p>
<p><code>apply()</code> 與 <code>call()</code> 差異則是剛剛提到的 第一個參數後面的參數部分， 其他地方完全一致，<code>call()</code> 第一個參數後面的參數，是接受任何型別的參數 ，而  <code>apply()</code> 則只能使用第二個參數，並且只能接受陣列寫法的參數，如果是陣列以外的都會跳錯。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span> : <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params">item1,item2,item3</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name,item1,item2,item3)</span><br><span class="line">&#125;</span><br><span class="line">showName.apply(obj,[<span class="string">&#x27;test&#x27;</span>,&#123;&#125;, [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>] ]) <span class="comment">// Jack, test, &#123;&#125;, [0,1,2] </span></span><br><span class="line">showName.apply(obj,<span class="string">&#x27;test&#x27;</span>, &#123;&#125;, [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]) <span class="comment">// 跳錯</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <code>bind()</code> 算是比較常用的，和 <code>call()</code>、 <code>apply()</code> 不同，使用後函示並不會立刻執行，而是會回傳要替換 this 的函式，因此我們會需要再使用 <code>()</code> 呼叫替換後的函式，而參數部分則和 <code>call()</code>  接受任何形式的參數。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span> : <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params">item1,item2,item3</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name,item1,item2,item3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test = showName.bind(obj) </span><br><span class="line">test(<span class="string">&#x27;test&#x27;</span>, &#123;&#125;, [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p>關於 <code>call()</code>、 <code>apply()</code>  、 bind() 還有一點要提的是，使用第一個參數綁定 this 時，若如果我們傳入的是純值，那麼被替換的 <code>tihs</code> 會是以建構式的方式建立。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//String &#123;&#x27;test&#x27;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">Fn1.bind(<span class="string">&#x27;test&#x27;</span>)()</span><br></pre></td></tr></table></figure>

<p>而傳入 <code>undefined</code>  他則會替換成 window</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// Window</span></span><br><span class="line">&#125;</span><br><span class="line">Fn1.call(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure>

<p>關於這一點 MDN 也有解釋：</p>
<blockquote>
<p>注意，它可能是一個無法在函數內看到的值：若這個函數是在非嚴苛模式( non-strict mode ), null 、undefined 將會被置換成全域變數，而原生型態的值將會被封裝</p>
</blockquote>
<h2 id="嚴格模式"><a href="#嚴格模式" class="headerlink" title="嚴格模式"></a>嚴格模式</h2><p>由於  JavaScript 這個語言特性，算是相對寬鬆，因此 ES5 新增 嚴格模式，用來規範 JavaScript 寫法，並對程式碼做一些限制。</p>
<p> 若要使用嚴格模式會需要再該執行環境添加  <code>&#39;use strict&#39;</code> 的字串，如果我們直接在全域使用  <code>&#39;use strict&#39;</code>  基本上就是全部的程式碼都會變為嚴格模式。</p>
<p>而我們本次介紹的 <code>this</code>  在嚴格模式下，部分的指向也會有所變動，那麼嚴格模式下 <code>this</code> 有甚麼更動?</p>
<p>主要有三點：</p>
<ul>
<li>簡易呼叫 this 原本指向 <code>window</code>  ，嚴格模式下一律都會被轉為 <code>undefined</code> 。</li>
<li>使用  <code>call()</code>、 <code>apply()</code>  、 <code>bind()</code> 對 <code>this</code> 值做綁定時，若綁定的是純值， <code>this</code> 的值會是建構式，嚴格模式下則會是純值本身。</li>
<li>同上透過 <code>call()</code>、 <code>apply()</code>  、 <code>bind()</code> 對 <code>this</code> 值做綁定時，綁定的是 <code>undefined</code> 、<code>Null</code> ，<code>this</code>  會是 window，嚴格模式下則會是傳入的 <code>undefined</code> 、<code>Null</code> 。</li>
</ul>
<p>簡易呼叫的範例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">	&#x27;use strict&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// undefined </span></span><br><span class="line">&#125;</span><br><span class="line">Fn()</span><br><span class="line"></span><br><span class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">	&#x27;use strict&#x27;</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//undefined *3</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>this</code> 綁定 <code>undefined</code> 、與純值的範例</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">	&#x27;use strict&#x27;</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line">Fn1.call(<span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">	&#x27;use strict&#x27;</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// &#x27;test&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">Fn2.call(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ul>
<li><p>JavaScript 核心篇 (六角學院）</p>
</li>
<li><p><a href="https://hsiangfeng.github.io/javascript/20210403/2190440925/">或許我從一開始就沒有很懂  this</a></p>
</li>
<li><p><a href="https://hsiangfeng.github.io/javascript/20190418/1842588803/">關於this是一個很神奇的東西這件事情</a> </p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day18) 原型特性與繼承</title>
    <url>/2021/10/03/JS-core/(Day18)%20%E5%8E%9F%E5%9E%8B%E7%89%B9%E6%80%A7%E8%88%87%E7%B9%BC%E6%89%BF/</url>
    <content><![CDATA[<h2 id="什麼是原型？"><a href="#什麼是原型？" class="headerlink" title="什麼是原型？"></a>什麼是原型？</h2><p>JavaScript 這個語言有一個特性，所以資料其實都是以『物件』方式做建立，因此也可以說 JavaScript 所有資料都有原型，而到底什麼是原型？</p>
<p>單純用文字比喻的話，原型其實像是藍圖，我們可以在原型設定各種屬性、方法，用來幫助我們建立實體資料，而實體資料則會帶者原型上的屬性以及方法，以下面圖片為例：<br><img src="https://i.imgur.com/yEAJ9VU.png"></p>
<p>上述圖片只是幫助思考『原型的概念』而已，實際程式碼來說的話，我們會使用函示建構式、ES6 的 Class 來當作衣服的原型，而實體資料則是：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> blackT = &#123;</span><br><span class="line">	<span class="attr">color</span>:<span class="string">&#x27;black&#x27;</span>,</span><br><span class="line">	<span class="attr">material</span>:<span class="string">&#x27;棉&#x27;</span>,</span><br><span class="line">	<span class="attr">size</span>:<span class="string">&#x27;L&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> darkBlueT = &#123;</span><br><span class="line">	<span class="attr">color</span>:<span class="string">&#x27;darkBlue &#x27;</span>,</span><br><span class="line">	<span class="attr">material</span>:<span class="string">&#x27;聚酯纖維&#x27;</span>,</span><br><span class="line">	<span class="attr">size</span>:<span class="string">&#x27;XL&#x27;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>這章節還不會講到如何建立原型，不過我們先將 <code>blackT</code>  物件丟到 console 並且再次呼叫，會顯示剛剛建立的 <code>blackT</code>  物件，不過物件的屬性底下還會有 <code>[[Prototype]]</code> 的東西，而這個 <code>[[Prototype]]</code>  其實就是今天介紹的原型。</p>
<p><img src="https://i.imgur.com/omQylhI.png"></p>
<p>值得一提的是原型本身還可以再繼承原型，因此這樣一段一段，因此又被稱做原型鍊，繼續使用衣服圖做範例：</p>
<p><img src="https://i.imgur.com/bs5HxLh.png"></p>
<p>P.S 過去文章會寫做 <code>__proto__</code>  而不是 <code>[[Prototype]]</code>  ，這是因為 JavaScript 這語言本來就有對每筆資料設置 <code>[[prototype]]</code> ，ES5 之前並沒有標準方法來查詢這個隱藏屬性，因此瀏覽器使用  <code>__proto__</code>  這個方法來達成相關需求。</p>
<p>現在因為瀏覽器更新，所以 <code>__proto__</code>  改為正式的  <code>[[Prototype]]</code>  不過實際上還是可以使用 <code>__proto__</code>  等等相關方法，以上方 <code>blackT</code>  為例，使用 <code>console.log(blackT.__proto__)</code> 仍可以查到他的相關原型。</p>
<h2 id="原型的特性"><a href="#原型的特性" class="headerlink" title="原型的特性"></a>原型的特性</h2><p>以下是原型的特性:</p>
<ul>
<li>一樣具有物件的特性</li>
<li>向上查找特性</li>
<li>原型可共用方法與屬性</li>
</ul>
<p>這邊直接使用程式碼舉例比較好懂</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(array) </span><br></pre></td></tr></table></figure>

<p>這邊的 array 就是個實體，點開 console 上的  <code>array</code>  裡面的 <code>[[Prototype]]</code>  就是原型，這點上面有提到。</p>
<p>而 array 中的 <code>[[Prototype]]</code>  有著許多我們常用的 陣列方法，比如 <code>forEach()</code> 、 <code>filter()</code> ，這些方法正是透過原型繼承來的方法，這也提到一個重點：『若實體要取用原型中的方法，便是使用  <code>.</code>  這個運算子來使用』，這個重點也和上面提到的 『一樣具有物件的特性』是相同的。</p>
<p><img src="https://i.imgur.com/R6Sp6bE.png"></p>
<p>眼尖的朋友就會發現在 <code>forEach</code>、 <code>filter</code> 這些方法底下，還有一層 <code>[[Prototype]]</code> ，這正是上面提到的，原型上還有原型，同時也是『原型向上查找的特性』，同時不管是陣列、還是函示在最上層的原型都會是物件。</p>
<p><img src="https://i.imgur.com/ApD47yn.png"></p>
<p>接下來可以驗證一下「原型的方法與屬性是共用的」這一點</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">array.__proto__.dobuleNum= <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> item*<span class="number">2</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(array.dobuleNum()) <span class="comment">//[2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<p>範例中使用 <code>__proto__</code>  來新增  <code>dobuleNum</code>  這個方法，而 <code>dobuleNum</code>  就是將陣列中的值 ＊2 在回傳。透過  <code>console.log(array.dobuleNum())</code>  也會確實看到回傳 <code>[2,4,6]</code> 的值。</p>
<p>接者我們在新增一個陣列變數來試試看上面觀念是否正確。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newArray = [<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>]</span><br><span class="line"><span class="built_in">console</span>.log(newArray .dobuleNum()) <span class="comment">//[110, 132, 154]</span></span><br></pre></td></tr></table></figure>

<p>最後這邊要提醒一下，實做中是不建議使用 <code>__proto__</code>  來製作原型方法，主要是這方法會污染所有原型，並讓原型來源難以查找、確認，比較實際的方法是使用原型的建構式，這寫是下一章節的主題。</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ul>
<li>JavaScript 核心篇 (六角學院）</li>
<li><a href="https://hsiangfeng.github.io/javascript/20210124/2151565856">JavaScript 核心觀念(48)-繼承與原型鍊 - 原型在哪裡？</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day 20) Object.create 建立多層繼承</title>
    <url>/2021/10/03/JS-core/(Day20)%20Object.create%20%E5%BB%BA%E7%AB%8B%E5%A4%9A%E5%B1%A4%E7%B9%BC%E6%89%BF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上回介紹了如何使用建構式來建立原型，接著今天介紹使用  <code>Object.create()</code> 建立多層原型，先前在 T Shirt 例子有提到 ， T Shirt 的原型是衣服，而衣服原型，仍然能有原型，這種多層原型就會使用 <code>Object.create()</code>  這個方法。  </p>
<p><img src="https://i.imgur.com/weK2krQ.png"></p>
<h2 id="什麼是-Object-create"><a href="#什麼是-Object-create" class="headerlink" title="什麼是 Object.create()"></a>什麼是 Object.create()</h2><p><code>Object.create()</code> 這個功能簡單來說就是，建立一個新的原型物件，而這個原型物件是沒有實體的，這邊使用範例來觀察</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Ryder = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> student = <span class="built_in">Object</span>.create(Ryder)</span><br><span class="line"><span class="built_in">console</span>.log(student) <span class="comment">//&#123;&#125;</span></span><br><span class="line">student.name <span class="comment">// Ryder</span></span><br></pre></td></tr></table></figure>

<p> 雖然 <code>student</code> 實體仍是空物件，但我們使用 <code>student.name</code>  可以看到他會回傳 Ryder</p>
<p><img src="https://i.imgur.com/H4mmY75.png"></p>
<p>這是因為 <code>Object.create()</code> 的功能，讓 <code>student</code> 的原型繼承  <code>Ryder</code> 的內容 ，可以點開 <code>student</code>  回傳的空物件，看看他 <code>[[Prototype]]</code> 的結構：</p>
<p><img src="https://i.imgur.com/92O8I9K.png"></p>
<p>這樣便清楚 <code>Object.create()</code>  的功能其實就是能夠讓參數中的內容，成為目標的原型。</p>
<h2 id="透過-Object-create-建立多層原型"><a href="#透過-Object-create-建立多層原型" class="headerlink" title="透過 Object.create() 建立多層原型"></a>透過 Object.create() 建立多層原型</h2><p>這邊複製之前的 <code>TShirt</code> 程式碼</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TShirt</span>(<span class="params">color,material,size</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.color = color</span><br><span class="line">	<span class="built_in">this</span>.material = material</span><br><span class="line">	<span class="built_in">this</span>.size = size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TShirt.prototype.clothe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`穿上 <span class="subst">$&#123;<span class="built_in">this</span>.color&#125;</span> T Shit`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BlackTShit = <span class="keyword">new</span> TShirt(<span class="string">&#x27;black&#x27;</span>,<span class="string">&#x27;棉&#x27;</span>,<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>目前是的原型鍊是</p>
<p>BlackTShit (子層） ⇒ TShirt （父層） </p>
<p>預期在 TShirt 上一層在新增一層 <code>apparel</code>  原型，也就是讓原型鍊變成</p>
<p>BlackTShit ⇒ TShirt ⇒ apparel (服飾）</p>
<p>接下來就是新增 <code>apparel</code> 原型，並使用剛剛介紹的 <code>Object.create()</code> ， 讓 <code>apparel</code> 成為 <code>TShirt</code> 的原型，以下是範例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新的一層原型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apparel</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.type = type || <span class="string">&#x27;T Shirt&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 為新原型新增方法</span></span><br><span class="line">apparel.prototype.mirror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`我穿著 <span class="subst">$&#123;<span class="built_in">this</span>.color&#125;</span> 的 <span class="subst">$&#123;<span class="built_in">this</span>.type&#125;</span> `</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TShirt</span>(<span class="params">color,material,size</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.color = color</span><br><span class="line">	<span class="built_in">this</span>.material = material</span><br><span class="line">	<span class="built_in">this</span>.size = size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Object.create 讓 TShirt 原型繼承 apparel 原型</span></span><br><span class="line">TShirt.prototype = <span class="built_in">Object</span>.create(apparel.prototype)</span><br><span class="line"></span><br><span class="line">TShirt.prototype.clothe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`穿上 <span class="subst">$&#123;<span class="built_in">this</span>.color&#125;</span> T Shit`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> BlackTShit = <span class="keyword">new</span> TShirt(<span class="string">&#x27;black&#x27;</span>,<span class="string">&#x27;棉&#x27;</span>,<span class="string">&#x27;L&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在這段範例中要特別注意的是這一段：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">TShirt.prototype = <span class="built_in">Object</span>.create(apparel.prototype)</span><br></pre></td></tr></table></figure>

<p>這邊是讓 <code>TShirt</code> 這個函式建構式的原型，繼承了 <code>apparel</code> 函式就建構式的原型。</p>
<h2 id="多層繼承中的眉眉角角"><a href="#多層繼承中的眉眉角角" class="headerlink" title="多層繼承中的眉眉角角"></a>多層繼承中的眉眉角角</h2><p>在完成上面使用 <code>Object.create()</code> 串連原型後，接著試者使用 <code>mirror()</code> 以及 <code>clothe()</code> 方法。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">BlackTShit.clothe() <span class="comment">//穿上 black T Shit</span></span><br><span class="line">BlackTShit.mirror() <span class="comment">//我穿著 black 的 undefined</span></span><br></pre></td></tr></table></figure>

<p>可以發現在 <code>apparel</code>  這一層原型新增的方法雖然成功了， <code>mirror()</code> 方法中的 <code>type</code> 屬性卻無法正確顯示，這是因為使用 <code>Object.create()</code> 讓 <code>TShirt</code> 繼承了 <code>apparel</code>  的原型，但卻沒有繼承 <code>apparel</code> 的『建構函式』。<br>這時候需要在 <code>TShirt</code>  建構函式中使用 <code>call()</code> 方法，來讓 <code>TShirt</code> 中的 <code>this</code> 綁定到 <code>apparel</code> 上，而這段其實就是將兩個 建構函式 串接起來，並在傳入 <code>&#39;T Shirt&#39;</code> 字串當作 <code>apparel</code> 的 <code>type</code> 參數。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apparel</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.type = type || <span class="string">&#x27;帽 T&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">apparel.prototype.mirror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我穿著 <span class="subst">$&#123;<span class="built_in">this</span>.color&#125;</span> 的 <span class="subst">$&#123;<span class="built_in">this</span>.type&#125;</span> `</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TShirt</span>(<span class="params">color,material,size</span>)</span>&#123;</span><br><span class="line">  apparel.call(<span class="built_in">this</span>, <span class="string">&#x27;T Shirt&#x27;</span>)</span><br><span class="line">  <span class="built_in">this</span>.color = color</span><br><span class="line">  <span class="built_in">this</span>.material = material</span><br><span class="line">  <span class="built_in">this</span>.size = size</span><br><span class="line">&#125;</span><br><span class="line">TShirt.prototype = <span class="built_in">Object</span>.create(apparel.prototype)</span><br><span class="line">TShirt.prototype.constructor = TShirt</span><br><span class="line">TShirt.prototype.clothe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`穿上 <span class="subst">$&#123;<span class="built_in">this</span>.color&#125;</span> T Shit`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BlackTShit = <span class="keyword">new</span> TShirt(<span class="string">&#x27;black&#x27;</span>,<span class="string">&#x27;棉&#x27;</span>,<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">BlackTShit.mirror()</span><br><span class="line">BlackTShit.clothe()</span><br></pre></td></tr></table></figure>

<p> 這樣在 console 打上  <code>BlackTShit</code> 便會看到，來自 <code>TShirt</code> 原型 、<code>apparel</code> 原型上的完整屬性以及內容了。<br><img src="https://i.imgur.com/zPPoKba.png"></p>
<p>最後這邊看起來程式碼已經相當的完整了，但是如果要讓原型鍊完整的話，其實還必須在 <code>Object.create()</code> 底下加上 <code>TShirt.prototype.constructor = TShirt</code> ，這是因為在 <code>Object.create()</code> 設定時就會將原本 <code>TShirt</code>  原型中的內容在加回來。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apparel</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.type = type || <span class="string">&#x27;帽 T&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 為新原型新增方法</span></span><br><span class="line">apparel.prototype.mirror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`我穿著 <span class="subst">$&#123;<span class="built_in">this</span>.color&#125;</span> 的 <span class="subst">$&#123;<span class="built_in">this</span>.type&#125;</span> `</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TShirt</span>(<span class="params">color,material,size</span>)</span>&#123;</span><br><span class="line">	apparel.call(<span class="built_in">this</span>, <span class="string">&#x27;T Shirt&#x27;</span>)</span><br><span class="line">  <span class="built_in">this</span>.color = color</span><br><span class="line">	<span class="built_in">this</span>.material = material</span><br><span class="line">	<span class="built_in">this</span>.size = size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透過 Object.create() 為 TShirt  </span></span><br><span class="line">TShirt.prototype = <span class="built_in">Object</span>.create(apparel.prototype)</span><br><span class="line">TShirt.prototype.constructor = TShirt</span><br><span class="line"></span><br><span class="line">TShirt.prototype.clothe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`穿上 <span class="subst">$&#123;<span class="built_in">this</span>.color&#125;</span> T Shit`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> BlackTShit = <span class="keyword">new</span> TShirt(<span class="string">&#x27;black&#x27;</span>,<span class="string">&#x27;棉&#x27;</span>,<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">BlackTShit.mirror()</span><br><span class="line">BlackTShit.clothe()</span><br></pre></td></tr></table></figure>

<p>這樣就是完整的讓原型繼承原型的方法了。</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ul>
<li>JavaScript 核心篇 (六角學院）</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day 21) ES6 class 語法糖</title>
    <url>/2021/10/03/JS-core/(Day21)%20ES6%20class%20%E8%AA%9E%E6%B3%95%E7%B3%96/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面有花幾篇介紹了，原型鍊以及使用建構式、以及使用 <code>Object.create()</code> 建立多層原型。<br>​<br>一邊介紹也會發現原型寫法，容易有不好閱讀的問題，例如：<br>​</p>
<ul>
<li>函式建構式容易和一般函式搞混。</li>
<li>函式建構式只能新增的實體，若要新增方法，需在在函式建構式的原型上新增方法。</li>
<li>多層原型時需另外使用  <code>Object.create()</code>  將子層、父層的原型串起來。<br>​<br>整體來說就是閱讀上不夠直覺，原型相關語法讓人感覺是拼拼湊湊組合出來，因此 JavaScript 在 ES6 時，有新增了原型的語法糖 <code>class</code>，雖然整個概念和原本寫法一樣，但是用 <code>class</code> 建立的原型確實更容易理解也更容易閱讀。<br>​<h2 id="使用-class-建立原型"><a href="#使用-class-建立原型" class="headerlink" title="使用 class 建立原型"></a>使用 class 建立原型</h2>以上次衣服範例：<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TShirt</span>(<span class="params">color,material,size</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color = color</span><br><span class="line">    <span class="built_in">this</span>.material = material</span><br><span class="line">    <span class="built_in">this</span>.size = size</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">TShirt.prototype.clothe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`穿上 <span class="subst">$&#123;<span class="built_in">this</span>.color&#125;</span> T Shit`</span>);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> BlackTShit = <span class="keyword">new</span> TShirt(<span class="string">&#x27;black&#x27;</span>,<span class="string">&#x27;棉&#x27;</span>,<span class="string">&#x27;L&#x27;</span>)</span><br></pre></td></tr></table></figure>
​<br><code>class</code> 語法糖寫成就會是：<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TShirt</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">color,material,size</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = color</span><br><span class="line">        <span class="built_in">this</span>.material = material</span><br><span class="line">        <span class="built_in">this</span>.size = size</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="title">clothe</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`穿上 <span class="subst">$&#123;<span class="built_in">this</span>.color&#125;</span> T Shit`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> BlackTShit = <span class="keyword">new</span> TShirt(<span class="string">&#x27;black&#x27;</span>,<span class="string">&#x27;棉&#x27;</span>,<span class="string">&#x27;L&#x27;</span>)</span><br></pre></td></tr></table></figure>
​<br>從範例可以發現， <code>class</code> 語法糖最大特色是所有原型設定，都會寫到 <code>class</code> 中， <code>constructor()</code> 就是用來設定原本的函式建構式，而原型方法則是直接新增在 class 底下，相當直覺。<br>​<br>在來看看使用 <code>Object.create()</code>  建立多層原型，以及 <code>class</code> 建立多層原型的對比，在開始寫範例之前，要先介紹 <code>class</code> 會使用到的兩個新方法  <code>extends</code> 、 <code>super</code> 。<br>​</li>
<li><code>extends</code> : 繼承於另一個原型之下</li>
<li><code>super</code> : 使用上層的值(屬性)<br>​<br>原始寫法：<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apparel</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type || <span class="string">&#x27;帽 T&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">apparel.prototype.mirror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`我穿著 <span class="subst">$&#123;<span class="built_in">this</span>.color&#125;</span> 的 <span class="subst">$&#123;<span class="built_in">this</span>.type&#125;</span> `</span>)</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TShirt</span>(<span class="params">color,material,size</span>)</span>&#123;</span><br><span class="line">    apparel.call(<span class="built_in">this</span>, <span class="string">&#x27;T Shirt&#x27;</span>)</span><br><span class="line">  <span class="built_in">this</span>.color = color</span><br><span class="line">    <span class="built_in">this</span>.material = material</span><br><span class="line">    <span class="built_in">this</span>.size = size</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">TShirt.prototype = <span class="built_in">Object</span>.create(apparel.prototype)</span><br><span class="line">TShirt.prototype.constructor = TShirt</span><br><span class="line">​</span><br><span class="line">TShirt.prototype.clothe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`穿上 <span class="subst">$&#123;<span class="built_in">this</span>.color&#125;</span> T Shit`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> BlackTShit = <span class="keyword">new</span> TShirt(<span class="string">&#x27;black&#x27;</span>,<span class="string">&#x27;棉&#x27;</span>,<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">BlackTShit.mirror() <span class="comment">// 我穿著 black 的 T Shirt </span></span><br><span class="line">BlackTShit.clothe() <span class="comment">//穿上 black T Shit</span></span><br></pre></td></tr></table></figure>
​<br>class 版本：<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">apparel</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">type</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type || <span class="string">&#x27;帽 T&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">mirror</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`我穿著 <span class="subst">$&#123;<span class="built_in">this</span>.color&#125;</span> 的 <span class="subst">$&#123;<span class="built_in">this</span>.type&#125;</span> `</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 使用 extends 讓 TShirt 原型繼承 apparel </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TShirt</span> <span class="keyword">extends</span> <span class="title">apparel</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">color,material,size</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&#x27;T Shit&#x27;</span>) <span class="comment">// 使用 super() 讓 TShirt 原型能使用上一層的 apparel 的 type  屬性</span></span><br><span class="line">    <span class="built_in">this</span>.color = color</span><br><span class="line">        <span class="built_in">this</span>.material = material</span><br><span class="line">        <span class="built_in">this</span>.size = size</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="title">clothe</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`穿上 <span class="subst">$&#123;<span class="built_in">this</span>.color&#125;</span> T Shit`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> BlackTShit = <span class="keyword">new</span> TShirt(<span class="string">&#x27;black&#x27;</span>,<span class="string">&#x27;棉&#x27;</span>,<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">BlackTShit.mirror() <span class="comment">// 我穿著 black 的 T Shirt </span></span><br><span class="line">BlackTShit.clothe() <span class="comment">//穿上 black T Shit</span></span><br></pre></td></tr></table></figure>
​<br>從以上範例可以看的出來，即變使用多層建立的方法，也可以發現 <code>class</code>  的原型設定都是在 <code>class</code> 方法內，因此比起原本的原型設定，使用 <code>class</code>  寫法，對開發者來說是友善許多。<br>​<br>最後來說說兩個在 class 中新增的特有方法<br>​</li>
<li>static 靜態方法</li>
<li>Setter, Getter<br>​<h3 id="static-靜態方法"><a href="#static-靜態方法" class="headerlink" title="static 靜態方法"></a>static 靜態方法</h3>​<br>若要使用 <code>static</code>  需在 class 的方法名稱前添加  <code>static</code> ，設置了 <code>static</code> 的方法，只能夠讓原型使用，一般實體資料是無法使用。<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TShirt</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">color,material,size</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = color</span><br><span class="line">        <span class="built_in">this</span>.material = material</span><br><span class="line">        <span class="built_in">this</span>.size = size</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">clothe</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`穿上 <span class="subst">$&#123;<span class="built_in">this</span>.color&#125;</span> T Shit`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> BlackTShit = <span class="keyword">new</span> TShirt(<span class="string">&#x27;black&#x27;</span>,<span class="string">&#x27;棉&#x27;</span>,<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">BlackTShit.clothe() <span class="comment">// BlackTShit.clothe is not a function</span></span><br><span class="line">TShirt.clothe() <span class="comment">// 穿上 undefined T Shit</span></span><br></pre></td></tr></table></figure>
​<h3 id="Setter-Getter"><a href="#Setter-Getter" class="headerlink" title="Setter, Getter"></a>Setter, Getter</h3>​<br>和 <code>static</code> 一樣若要使用 Setter ﹑ Getter ，需要將  <code>set</code> 、 <code>get</code> 寫在 class 的方法前，而這兩個方法從名稱便可得知是功能是傳入以及傳出。<br>​</li>
<li><code>set</code> 傳入資料，可以透過 <code>set</code> 方法修改原型中的資料，要注意的是這邊使用的不是呼叫函式的 <code>()</code> ，而是使用 <code>=</code>  運算子提供資料，因此一次只能傳送一個值。<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TShirt</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">color, material, size</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = color</span><br><span class="line">    <span class="built_in">this</span>.material = material</span><br><span class="line">    <span class="built_in">this</span>.size = size</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">chageColor</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = color</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">clothe</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`穿上 <span class="subst">$&#123;<span class="built_in">this</span>.color&#125;</span> T Shit`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> BlackTShit = <span class="keyword">new</span> TShirt(<span class="string">&#x27;black&#x27;</span>,<span class="string">&#x27;棉&#x27;</span>,<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">BlackTShit.clothe() <span class="comment">// 穿上 black T Shit</span></span><br><span class="line">BlackTShit.chageColor = <span class="string">&#x27;Red&#x27;</span></span><br><span class="line">BlackTShit.clothe() <span class="comment">//  穿上 Red T Shit</span></span><br></pre></td></tr></table></figure>
​</li>
<li>使用 <code>get</code> 可以獲得原型中的資料，和 <code>set</code> 方法一樣， <code>get</code> 方法不會使用到 <code>()</code><br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TShirt</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">color,material,size</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = color</span><br><span class="line">        <span class="built_in">this</span>.material = material</span><br><span class="line">        <span class="built_in">this</span>.size = size</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">get</span> <span class="title">getColor</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> BlackTShit = <span class="keyword">new</span> TShirt(<span class="string">&#x27;black&#x27;</span>,<span class="string">&#x27;棉&#x27;</span>,<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">BlackTShit.getColor <span class="comment">// &#x27;black&#x27;</span></span><br></pre></td></tr></table></figure>
​<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2></li>
<li>JavaScript 核心篇 (六角學院）<br>​</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day 22) ES6 的 let 、const</title>
    <url>/2021/10/03/JS-core/(Day22)%20ES6%20%E7%9A%84%20let%20%E3%80%81const/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 ES6 新增兩種變數方法 <code>let</code> 、 <code>const</code> ，不過我們比較常把 <code>const</code> 叫做常數，主要是因為 <code>var</code> 的特性 容易觸發 Bug ， 這邊與 <code>var</code> 的差異主要有：</p>
<ul>
<li>作用域範圍不同</li>
<li>提升特性不同</li>
<li>全域不掛在 window 下</li>
</ul>
<p>在提及這些不同特性之前，先大致介紹一下這兩個用法的差別。</p>
<h2 id="let-、-const-基本介紹"><a href="#let-、-const-基本介紹" class="headerlink" title="let 、 const 基本介紹"></a>let 、 const 基本介紹</h2><p><code>let</code>  能夠重新賦值，但不能重複宣告</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> String1 = <span class="string">&#x27;test1&#x27;</span></span><br><span class="line">String1 =  <span class="string">&#x27;test2&#x27;</span></span><br><span class="line"><span class="keyword">let</span> String1 = <span class="string">&#x27;test3&#x27;</span> <span class="comment">// 重複宣告錯誤， Uncaught SyntaxError: Identifier &#x27;String1&#x27; has already been declared</span></span><br></pre></td></tr></table></figure>

<p><code>const</code>  不能重新賦值，也不能重新宣告。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> String1 = <span class="string">&#x27;test1&#x27;</span></span><br><span class="line"><span class="keyword">const</span> String1 = <span class="string">&#x27;test2&#x27;</span> <span class="comment">//  重複宣告錯誤， Uncaught SyntaxError: Identifier &#x27;String1&#x27; has already been declared</span></span><br><span class="line">String1 = <span class="string">&#x27;test3&#x27;</span> <span class="comment">// 賦值錯誤， Uncaught TypeError: invalid assignment to const &#x27;String1&#x27;</span></span><br></pre></td></tr></table></figure>

<p>要補充一點如果 <code>const</code> 的值是物件，對物件底下的屬性賦值，  <code>const</code> 則能接受這種操作繼續使用。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">obj.name = <span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; name: &#x27;Ryder&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = []</span><br><span class="line">array.push(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(array) <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>
<h2 id="作用域不同"><a href="#作用域不同" class="headerlink" title="作用域不同"></a>作用域不同</h2><p>在過去 <code>var</code> 作用域是根據函式作用域，而 <code>let</code> 、 <code>const</code> 則是以 <code>&#123; ... &#125;</code> Block 區塊做為作用域，來看看以下範例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name1 = <span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line"><span class="keyword">let</span> name2 = <span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> name1 = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">	<span class="keyword">let</span> name2 = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line"><span class="built_in">console</span>.log(name1, name2)  <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>結果是 <code>Ryder, Ryder</code>  ，這範例很好理解，不論是 <code>var</code> 還是 <code>let</code> ， <code>name = &#39;Jack&#39;</code> 的作用範圍都只在 <code>test()</code> 這個函式中，console 的位置則是在全域，自然都會是 <code>Ryder</code> ，那麼再來看看這個範例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name1 = <span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line"><span class="keyword">let</span> name2 = <span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">var</span> name1 = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">let</span> name2 = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name1 , name2)  <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>結果會是 <code>Jack, Ryder</code> ，這是因為上面提到的， <code>let</code>  是以 <code>&#123; ... &#125;</code> 區塊做為作用域，因此 <code>let name1 = &#39;Jack&#39;</code> 這個語法的有效範圍只會存在於  <code>&#123; ... &#125;</code> 之中，而 <code>var</code> 則會被 <code>&#123; ... &#125;</code> 中的 <code>var name1 = &#39;Jack&#39;</code> ，直接做替換，因此 <code>name1</code> 會是 <code>&#39;Jack&#39;</code> 。</p>
<p>這邊要補充一下， 這邊提到的 <code>&#123; ... &#125;</code> 並不是物件，而是一個作用域範圍，主要是為了搭配 <code>let</code> 、 <code>const</code> 特性 ES6 才引入的，不過實做中通常不會刻意使用 <code>&#123; ... &#125;</code> 去區分作用域。</p>
<h2 id="提升特性不同"><a href="#提升特性不同" class="headerlink" title="提升特性不同"></a>提升特性不同</h2><p>在提升章節我們有提到，JavaScript 在編譯程式碼時，會分為兩個階段：<br>1.創造階段<br>2.執行階段<br><code>var</code> 變數會先在 創造階段 被建立，進入執行階段才會實際賦值，而在創造階段中的 <code>var</code> 變數，他的值會是 <code>undefined</code> ，如這個範例:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(name1)  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name1 = <span class="string">&#x27;Ryder&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>let</code> 雖然也有提升概念，也同樣分成:<br>1.創造階段<br>2.執行階段<br>但在創造階段和 <code>var</code> 不同，<code>let</code> 在創造階段不是直接顯示 <code>undefined</code> ，他是進入一個 <strong>暫時性死區 (TDZ)</strong> 的狀況，<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_and_errors_with_let">MDN 文件</a>是這麼描述的:</p>
<blockquote>
<p>The variable is in a “temporal dead zone” from the start of the block until the initialization is processed</p>
</blockquote>
<p>如果我們在 暫時性死區 的狀態去取得 <code>let</code> 變數的值，瀏覽器會跳錯，要注意的是，不同瀏覽器跳出的錯誤訊息會不同，如下範例：</p>
<p>FireFox 版本</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(name2)  <span class="comment">// Uncaught ReferenceError: can&#x27;t access lexical declaration &#x27;name1&#x27; before initialization</span></span><br><span class="line"><span class="keyword">let</span> name2 = <span class="string">&#x27;Ryder&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Chrome 版本</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(name2)  <span class="comment">//Uncaught ReferenceError: name1 is not defined</span></span><br><span class="line"><span class="keyword">let</span> name2 = <span class="string">&#x27;Ryder&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="全域建立變數"><a href="#全域建立變數" class="headerlink" title="全域建立變數"></a>全域建立變數</h2><p> 上面有提到到 <code>let</code> 、 <code>const</code>  是根據 <code>&#123; ... &#125;</code> 來區分作用域的，這邊要提一點的是 <code>var</code>  全域建立時，會是掛在 window  下。</p>
<p>而使用  <code>let</code> 、 <code>const</code>  在全域建立變數時，他並不會掛在  window  下，但我們若直接呼叫變數，他也會正確顯示，如範例</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name1= <span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line"><span class="keyword">let</span> name2 = <span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.name1 <span class="comment">// &#x27;Ryder&#x27;</span></span><br><span class="line"><span class="built_in">window</span>.name2 <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">name1 <span class="comment">// &#x27;Ryder&#x27;</span></span><br><span class="line">name2 <span class="comment">// &#x27;Ryder&#x27;</span></span><br></pre></td></tr></table></figure>

<p>這個原因是出在全域執行環境(Global space) 上面，首先這個全域執行環境其實是由兩個環境所組成的</p>
<ul>
<li>全域物件 - Object Env</li>
<li>宣告環境 - Declare Env</li>
</ul>
<p>因此全域執行環境(Global space) 其實是一個由雙環境組成的東西，一般來說我們是看不到 Declare Env 的。</p>
<p>所以 <code>var</code> 其實是基於 ObjectEnv 宣告並加入到 Declare Env，而 <code>let</code>、<code>const</code> 則是只會宣告在 Declare Env 中，這也就是為什麼我們無法在 Window 上面看到由 <code>let</code>、<code>const</code> 宣告的變數但卻又可以正常取得到值的原因。</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ul>
<li>JavaScript 核心篇 (六角學院）</li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/block">MDN 文件 - 區塊</a></li>
<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/30">关于 const 和 let 声明的变量不在 window 上</a></li>
<li><a href="https://hsiangfeng.github.io/javascript/20200425/539985371/">淺談 var 與 let 的差異以及有無宣告變數的差異</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day23) ES6 箭頭函式</title>
    <url>/2021/10/03/JS-core/(Day23)%20ES6%20%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>跟變數一樣 JavaScript 在 ES6 為函式新添加一種寫法，他和傳統函式有以下差異：</p>
<ul>
<li>this 指向不同</li>
<li>沒有 arguments 參數</li>
<li>部分寫法箭頭函式不支援</li>
</ul>
<p>除了以上和傳統函式不同，箭頭函式本身一個可以縮寫特性，先來看一下範例：<br>這是原本傳統函式：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sayHi(<span class="string">&#x27;Ryder&#x27;</span>)) <span class="comment">//Hello Ryder</span></span><br></pre></td></tr></table></figure>

<p>如果是使用 箭頭函式 可以省略 <code>return</code> 以及 <code>&#123; &#125;</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHi = <span class="function">(<span class="params">name</span>)=&gt;</span> <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sayHi(<span class="string">&#x27;Ryder&#x27;</span>)) <span class="comment">//Hello Ryder</span></span><br></pre></td></tr></table></figure>

<p>當參數只有一個時，也可以將包著參數的 <code>()</code>  給省略。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHi = <span class="function"><span class="params">name</span> =&gt;</span> <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sayHi(<span class="string">&#x27;Ryder&#x27;</span>)) <span class="comment">//Hello Ryder</span></span><br></pre></td></tr></table></figure>
<h2 id="this-指向不同"><a href="#this-指向不同" class="headerlink" title="this 指向不同"></a>this 指向不同</h2><ul>
<li>在傳統函式中，會根據呼叫函式的方法會決定 <code>this</code>  的指向。</li>
<li>箭頭函式則並沒有自己的 <code>this</code>  ，箭頭函式的 <code>this</code> 會綁定到定義時所在的位置，跟呼叫方法無關，先來看看範例：</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">	<span class="attr">showName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">	<span class="attr">showName</span>:<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj1.showName() <span class="comment">// Jack</span></span><br><span class="line">obj2.showName() <span class="comment">// Ryder</span></span><br></pre></td></tr></table></figure>

<p>上面有提到，箭頭函式的 <code>this</code> 會綁定到定義時所在的位置，這是什麼意思呢？<br>簡單來說就是： 當該實體、變數在哪裡建立， <code>this</code> 就會指向哪裡，而上面範例的 <code>obj</code>  正是建立在 window 下的，因此 <code>this</code> 是指向 window。</p>
<h2 id="沒有-arguments-參數"><a href="#沒有-arguments-參數" class="headerlink" title="沒有 arguments 參數"></a>沒有 arguments 參數</h2><p>在函式基本章節有提到，傳統函式能夠透過  arguments 這個關鍵字獲得該函式所有參數，而這方法在箭頭函式中無法使用，如範例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>) <span class="comment">// Arguments(2) [&#x27;Ryder&#x27;, 123, ...]</span></span><br><span class="line">&#125;</span><br><span class="line">Fn1(<span class="string">&#x27;Ryder&#x27;</span>, <span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Fn2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>) <span class="comment">// VM940:2 Uncaught ReferenceError: arguments is not defined</span></span><br><span class="line">&#125;</span><br><span class="line">Fn2(<span class="string">&#x27;Ryder&#x27;</span>, <span class="number">123</span>)</span><br></pre></td></tr></table></figure>

<p>不過這點可以使用 ES6 新增的其餘參數，來獲得全部參數資料，只需要在參數部分填上 <code>...arg</code>  之後的 <code>arg</code>  便可獲得全部參數資料。（arg 可自定義名稱</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Fn3 = <span class="function">(<span class="params">...arg</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(arg) <span class="comment">//[&#x27;Ryder&#x27;, 123]</span></span><br><span class="line">&#125;</span><br><span class="line">Fn3(<span class="string">&#x27;Ryder&#x27;</span>, <span class="number">123</span>)</span><br></pre></td></tr></table></figure>

<h2 id="部分寫法箭頭函式不支援"><a href="#部分寫法箭頭函式不支援" class="headerlink" title="部分寫法箭頭函式不支援"></a>部分寫法箭頭函式不支援</h2><h3 id="建構式函式"><a href="#建構式函式" class="headerlink" title="建構式函式"></a>建構式函式</h3><p>上面有提到箭頭含是沒有自己的 <code>this</code> ，因此建構式函式自然無法使用</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TShirt = <span class="function">(<span class="params">color,material,size</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.color = color</span><br><span class="line">	<span class="built_in">this</span>.material = material</span><br><span class="line">	<span class="built_in">this</span>.size = size</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> BlackTShit = <span class="keyword">new</span> TShirt(<span class="string">&#x27;black&#x27;</span>,<span class="string">&#x27;棉&#x27;</span>,<span class="string">&#x27;L&#x27;</span>) <span class="comment">//TShirt is not a constructor</span></span><br></pre></td></tr></table></figure>

<h3 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call/apply/bind"></a>call/apply/bind</h3><p>箭頭函式的 <code>this</code>  是無法使用  <code>call</code>、<code>apply</code> 、 <code>bind</code> 上述綁定 <code>this</code> 功能，箭頭函式的 <code>this</code> 會是固定的。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;Ryder&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Fn1 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">Fn1.call(obj) <span class="comment">// Window</span></span><br><span class="line">Fn2.call(obj) <span class="comment">// &#123;name: &#x27;Ryder&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ul>
<li>JavaScript 核心篇 (六角學院）</li>
<li><a href="https://hsiangfeng.github.io/javascript/20191012/2524618181/">EP.27 RE：從零開始的學習 JS 生活-第二十七日之 ES6 箭頭函式</a></li>
<li><a href="https://wcc723.github.io/javascript/2017/12/21/javascript-es6-arrow-function/">鐵人賽：箭頭函式 (Arrow functions)</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day24) 處理非同步的 Promise</title>
    <url>/2021/10/03/JS-core/(Day24)%20%E8%99%95%E7%90%86%E9%9D%9E%E5%90%8C%E6%AD%A5%E7%9A%84%20Promise/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在過去 JS 要處理 Ajax 這個非同步語法，會很容易用到 Callback 寫法，而 Callback 不但不好管理，還容易寫成 Callback Hell，如圖:<br><img src="https://i.imgur.com/uX4tMsl.png"><br>幸好 ES6 新增了  Promise  ，對於 JS 這個單執行序的語言 Promise 非常實用。<br>Promise 直接翻譯成中文會是<strong>承諾</strong> ，而 Promise 的使用結果也就分成兩種<br>​</p>
<ul>
<li>達成承諾，使用 <code>resolve()</code></li>
<li>承諾失敗，使用 <code>reject()</code><br>​<h2 id="實際使用-Promise"><a href="#實際使用-Promise" class="headerlink" title="實際使用 Promise"></a>實際使用 Promise</h2>​<br>而要使用 <code>Promise</code>  大致上分為兩個步驟：<br>​</li>
<li>使用 <code>new Promise()</code> 的函式建構式創造一個新的 Promise 物件</li>
<li>實際執行上面提到的 <code>Promise</code> 物件<br>​<br>在創造函式建構式時，函式建構式會帶上兩個參數 <code>resolve</code> 、 <code>reject</code> ， 第一個參數是用來執行 成功的方法，第二個則是 失敗的方法，這兩個參數名稱接可以自定義，不過實際開發時多數，仍會使用這個名稱做命名。<br>(這邊是把 Promise 寫成函式方法，因此可以帶入參數，在透過參數來做判斷。)<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseFn</span>(<span class="params"><span class="built_in">String</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 創造建構函式並帶上 resolve 、 reject 參數</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Promise 承諾的判斷</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">String</span>.length &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        resolve(<span class="string">`Promise 成功， <span class="subst">$&#123; <span class="built_in">String</span> &#125;</span> 共 <span class="subst">$&#123; <span class="built_in">String</span>.length &#125;</span> 個字 `</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;Promise 失敗&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
​<br>建立好 <code>Promise</code> 函式建構式後，便是執行 <code>Promise</code>  本身了，接者執行 <code>Promise</code> 本身時，我們可以使用 <code>then()</code> 、 <code>catch()</code>  他們會分別接收 <code>Promise</code>  成功 以及 <code>Promise</code> 失敗的結果，但他們需要寫上一個 Callback Function ，若要顯示 Promise 建構式中的  <code>resolve()</code> 、 <code>reject()</code>  設定的資料，那麼會需要在  Callback Function 中帶上一個參數，這些參數就會顯示 <code>resolve()</code> 、 <code>reject()</code>  設定的資料：<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseFn</span>(<span class="params"><span class="built_in">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">String</span>.length &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        resolve(<span class="string">`Promise 成功， <span class="subst">$&#123; <span class="built_in">String</span> &#125;</span> 共 <span class="subst">$&#123; <span class="built_in">String</span>.length &#125;</span> 個字 `</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;Promise 失敗&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">PromiseFn(<span class="string">&#x27;test&#x27;</span>)<span class="comment">// Promise 失敗</span></span><br><span class="line">​</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123; <span class="comment">// 第一個參數會回傳 resolve() 設定資料</span></span><br><span class="line">  <span class="built_in">console</span>.log(res)  </span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err) <span class="comment">// 第一個參數會回傳 reject() 設定資料</span></span><br><span class="line">&#125;)</span><br><span class="line">​</span><br><span class="line">PromiseFn(<span class="string">&#x27;Ryder&#x27;</span>) <span class="comment">//Promise 成功， Ryder 共 5 個字</span></span><br><span class="line">.then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
​<h2 id="All-與-Race"><a href="#All-與-Race" class="headerlink" title="All 與 Race"></a>All 與 Race</h2>​<br>扣除上面的 Promise 基本方法，Promise  還提供 <code>Promise.all()</code>  、 <code>Promise.race()</code>  兩種用法。<br>​</li>
<li>使用  <code>Promise.all()</code>  時，會執行 <code>Promise.all()</code> 中所有的 Promise 方法，並將回傳一個陣列，而這個陣列就是 <code>resolve()</code>  所提供的。<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseFn</span>(<span class="params"><span class="built_in">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">String</span>.length &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        resolve(<span class="string">`Promise 成功， <span class="subst">$&#123; <span class="built_in">String</span> &#125;</span> 共 <span class="subst">$&#123; <span class="built_in">String</span>.length &#125;</span> 個字 `</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;Promise 失敗&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="built_in">Promise</span>.all([PromiseFn(<span class="string">&#x27;Ryder&#x27;</span>), PromiseFn(<span class="string">&#x27;youtube&#x27;</span>)]).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">//[&#x27;Promise 成功， Ryder 共 5 個字 &#x27;, &#x27;Promise 成功， youtube 共 7 個字 &#x27;]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
​</li>
<li><code>Promise.race()</code> 和 <code>Promise.all()</code>  一樣，會同時執行 <code>Promise.race()</code>  中所有 Promise 方法，但他只會回傳最快執行完畢的 Promise 方法。<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    resolve(<span class="string">`直接執行 Promise`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseFn</span>(<span class="params"><span class="built_in">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">String</span>.length &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        resolve(<span class="string">`Promise 成功， <span class="subst">$&#123;<span class="built_in">String</span>&#125;</span> 共 <span class="subst">$&#123;<span class="built_in">String</span>.length&#125;</span> 個字 `</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;Promise 失敗&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="built_in">Promise</span>.race([PromiseFn(<span class="string">&#x27;Ryder&#x27;</span>), p]).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">//直接執行 Promise</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
​<h2 id="鏈式寫法"><a href="#鏈式寫法" class="headerlink" title="鏈式寫法"></a>鏈式寫法</h2>​<br>上面介紹的 <code>Promise.all()</code>   <code>Promise.race()</code> 都是會同時執行的方法，不過我們肯定會遇到需要依序執行 <code>Promise</code> 的狀況，在過去使用 Callback Function 時就會寫出超巢的 Callback Hell，不過 <code>Promise</code> 則提供了鏈式寫法，可以輕鬆的達成需求。<br>要使用  <code>Promise</code>  的鏈式寫法，只需要在 <code>then()</code>  中使用 <code>return</code>  並呼叫下一個 <code>Promise</code>  這樣變能使用 <code>.then()</code> 不斷串聯下去。<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    resolve(<span class="string">`直接執行 Promise`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseFn</span>(<span class="params"><span class="built_in">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">String</span>.length &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        resolve(<span class="string">`Promise 成功， <span class="subst">$&#123;<span class="built_in">String</span>&#125;</span> 共 <span class="subst">$&#123;<span class="built_in">String</span>.length&#125;</span> 個字 `</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;Promise 失敗&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">PromiseFn(<span class="string">&#x27;Ryder&#x27;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// Promise 成功， Ryder 共 5 個字</span></span><br><span class="line">    <span class="keyword">return</span> PromiseFn(<span class="string">&#x27;youtube&#x27;</span>) <span class="comment">// Promise 鏈式寫法，可以不斷寫 Promise 下去。</span></span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)  <span class="comment">// Promise 成功， youtube 共 7 個字 </span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 直接執行 Promise</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
​<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2></li>
<li>JavaScript 核心篇 (六角學院</li>
<li><a href="https://wcc723.github.io/javascript/2017/12/29/javascript-proimse/">鐵人賽：使用 Promise 處理非同步</a><br>​<br>​</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day25) Promise 語法糖 async &amp; await</title>
    <url>/2021/10/03/JS-core/(Day25)%20Promise%20%E8%AA%9E%E6%B3%95%E7%B3%96%20async%20&amp;%20await/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>async/await</code> 是 <code>Promise</code> 的語法糖，最主要是提升了 <code>Promise</code> 在鏈式寫法的可讀性，而 <code>async/await</code> 能辦到的 <code>Promise</code> 本身都能辦到，所以不少教學都提到要先明白 <code>Promise</code> ，才會看懂 <code>async/await</code> 。</p>
<h2 id="async-await-介紹"><a href="#async-await-介紹" class="headerlink" title="async/await 介紹"></a>async/await 介紹</h2><ul>
<li><p><code>async</code> 直接翻譯成中文是<strong>異步</strong>，也就是<strong>非同步</strong>的意思，若要使用 <code>async</code> 會將 <code>async</code> 放在函式旁，代表這個函式接下來會以同步方式來執行非同步的語法。</p>
</li>
<li><p><code>await</code> 翻譯成中文，則是<strong>等待</strong>， 一般是放在 <code>async</code> 函式中的 <code>Promise</code> 事件旁，代表接下來的程式碼會等待 <code>await</code> 方法完成後才執行。</p>
</li>
</ul>
<p>而 <code>async/await</code> 他們算是一組的，基本上使用碰上使用時機時，這兩個方法都會同時被使用 ，這部分用文字說明可能不是這麼好懂，直接來使用 Promise 章節提到的 <code>Promise</code> 鏈式寫法，以及 <code>async/await</code> 來做對比會比較好理解： </p>
<ul>
<li><p><code>Promise</code> 鏈式寫法：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    resolve(<span class="string">`直接執行 Promise`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseFn</span>(<span class="params"><span class="built_in">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">String</span>.length &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        resolve(<span class="string">`Promise 成功， <span class="subst">$&#123;<span class="built_in">String</span>&#125;</span> 共 <span class="subst">$&#123;<span class="built_in">String</span>.length&#125;</span> 個字 `</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;Promise 失敗&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PromiseFn(<span class="string">&#x27;Ryder&#x27;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// Promise 成功， Ryder 共 5 個字</span></span><br><span class="line">    <span class="keyword">return</span> PromiseFn(<span class="string">&#x27;youtube&#x27;</span>)</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)  <span class="comment">// Promise 成功， youtube 共 7 個字 </span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 直接執行 Promise</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li>
<li><p><code>async/await</code> 則可寫成：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    resolve(<span class="string">`直接執行 Promise`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseFn</span>(<span class="params"><span class="built_in">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">String</span>.length &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        resolve(<span class="string">`Promise 成功， <span class="subst">$&#123;<span class="built_in">String</span>&#125;</span> 共 <span class="subst">$&#123;<span class="built_in">String</span>.length&#125;</span> 個字 `</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;Promise 失敗&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data1 = <span class="keyword">await</span> PromiseFn(<span class="string">&#x27;Ryder&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(data1) <span class="comment">// Promise 成功， Ryder 共 5 個字</span></span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">await</span> PromiseFn(<span class="string">&#x27;youtube&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(data2) <span class="comment">// Promise 成功， youtube 共 7 個字</span></span><br><span class="line">  <span class="keyword">const</span> data3 = <span class="keyword">await</span> p</span><br><span class="line">  <span class="built_in">console</span>.log(data3); <span class="comment">// 直接執行 Promise</span></span><br><span class="line">&#125;</span><br><span class="line">usePromise();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>扣掉 <code>console.log</code> 可以發現  <code>async/await</code> 的寫法省去大量的 <code>then()</code> ，因此讓程式碼變的較容易閱讀。<br>而 <code>await</code> 其實可以塞入其他表達式的，但是實做中通常不會這麼使用:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    resolve(<span class="string">`直接執行 Promise`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseFn</span>(<span class="params"><span class="built_in">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">String</span>.length &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        resolve(<span class="string">`Promise 成功， <span class="subst">$&#123;<span class="built_in">String</span>&#125;</span> 共 <span class="subst">$&#123;<span class="built_in">String</span>.length&#125;</span> 個字 `</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;Promise 失敗&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data1 = <span class="keyword">await</span> <span class="number">1</span>+<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(data1) <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">await</span> PromiseFn(<span class="string">&#x27;youtube&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(data2) <span class="comment">// Promise 成功， youtube 共 7 個字</span></span><br><span class="line">  <span class="keyword">const</span> data3 = <span class="keyword">await</span> p</span><br><span class="line">  <span class="built_in">console</span>.log(data3); <span class="comment">// 直接執行 Promise</span></span><br><span class="line">&#125;</span><br><span class="line">usePromise();</span><br></pre></td></tr></table></figure>

<h2 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h2><p>使用 <code>async/await</code> 的寫法 ，只要使用 <code>await</code> 的 <code>Promise</code> 只要一失敗，接下來會回傳 <code>Promise</code> 的  <code>reject</code> 資料，接著 <code>await</code> 下的程式碼都不會被執行，比如：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    resolve(<span class="string">`直接執行 Promise`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseFn</span>(<span class="params"><span class="built_in">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">String</span>.length &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        resolve(<span class="string">`Promise 成功， <span class="subst">$&#123;<span class="built_in">String</span>&#125;</span> 共 <span class="subst">$&#123;<span class="built_in">String</span>.length&#125;</span> 個字 `</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;Promise 失敗&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data1 = <span class="keyword">await</span> PromiseFn(<span class="string">&#x27;Ryder&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(data1) <span class="comment">// Promise 成功， Ryder 共 5 個字</span></span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">await</span> PromiseFn(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(data2) <span class="comment">// Promise 失敗</span></span><br><span class="line">  <span class="keyword">const</span> data3 = <span class="keyword">await</span> p</span><br><span class="line">  <span class="built_in">console</span>.log(data3); </span><br><span class="line">&#125;</span><br><span class="line">usePromise();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>這種狀況會容易造成不清楚錯誤來源，在維護上會較為困難，也因此 <code>async/await</code> 的寫法，有提供另一種將 <code>Promise</code> 執行成功、失敗分開的寫法，就是 <code>try…catch</code>  ，<code>try</code>  專門存放執行 <code>Promise</code> 成功的結果，而 <code>catch</code>  則是執行 <code>Promise</code> 失敗的結果，這個方法跟原生 <code>Promise</code> 的 <code>.then()</code> 、 <code>.catch()</code> 十分相似，如範例:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    resolve(<span class="string">`直接執行 Promise`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseFn</span>(<span class="params"><span class="built_in">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">String</span>.length &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        resolve(<span class="string">`Promise 成功， <span class="subst">$&#123;<span class="built_in">String</span>&#125;</span> 共 <span class="subst">$&#123;<span class="built_in">String</span>.length&#125;</span> 個字 `</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;Promise 失敗&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data1 = <span class="keyword">await</span> PromiseFn(<span class="string">&#x27;Ryder&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(data1) <span class="comment">//Promise 成功， Ryder 共 5 個字 </span></span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">await</span> PromiseFn(<span class="string">&#x27;test&#x27;</span>); <span class="comment">// Promise 執行 catch</span></span><br><span class="line">  <span class="built_in">console</span>.log(data2) </span><br><span class="line">  <span class="keyword">const</span> data3 = <span class="keyword">await</span> p</span><br><span class="line">  <span class="built_in">console</span>.log(data3); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;catch&#x27;</span>, err); <span class="comment">//catch Promise 失敗</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">usePromise();</span><br></pre></td></tr></table></figure>
<p>要注意的是 <code>try</code>  中的 <code>Promise</code> 執行失敗，是會執行 <code>catch</code>  中的程式碼，而 <code>try</code>  中的程式碼一樣不會繼續執行下去。</p>
<h2 id="async-await-混搭-All-與-Race"><a href="#async-await-混搭-All-與-Race" class="headerlink" title="async/await 混搭 All 與 Race"></a>async/await 混搭 All 與 Race</h2><p>一開始有提到 <code>async/await</code> 是 <code>Promise</code> 的語法糖，因此 <code>async/await</code> 其實以可以和 <code>Promise.all</code>  、  <code>Promise.race</code> 一同使用，這也算是目前比較常用再處理 Ajax 處理順序的寫法：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    resolve(<span class="string">`直接執行 Promise`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PromiseFn</span>(<span class="params"><span class="built_in">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">String</span>.length &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        resolve(<span class="string">`Promise 成功， <span class="subst">$&#123;<span class="built_in">String</span>&#125;</span> 共 <span class="subst">$&#123;<span class="built_in">String</span>.length&#125;</span> 個字 `</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;Promise 失敗&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">usePromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> data1 = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([PromiseFn(<span class="string">&#x27;Ryder&#x27;</span>), PromiseFn(<span class="string">&#x27;youtube&#x27;</span>)])</span><br><span class="line">	<span class="built_in">console</span>.log(data1) <span class="comment">// [&#x27;Promise 成功， Ryder 共 5 個字 &#x27;, &#x27;Promise 成功， youtube 共 7 個字 &#x27;]</span></span><br><span class="line">	<span class="keyword">const</span> data2 = <span class="keyword">await</span> p</span><br><span class="line">	<span class="built_in">console</span>.log(data2) <span class="comment">// &#x27;直接執行 Promise&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ul>
<li>JavaScript 核心篇 (六角學院)</li>
<li><a href="https://wcc723.github.io/development/2020/10/16/async-await/">Async function / Await 深度介紹</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Async_await">MDN 文件 - async 和 await</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day26) 使用 fetch 串接 Ajax</title>
    <url>/2021/10/03/JS-core/(Day26)%20%E4%BD%BF%E7%94%A8%20fetch%20%E4%B8%B2%E6%8E%A5%20Ajax/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​<br><code>fetch</code> 是 JavaScript  ES6 新增的用來執行 Ajax 行為的方法，相比舊版的 <code>XMLHttprequest</code> 不論是閱讀程式碼、或是實際開發都方便不少，而 <code>fetch</code> 其實就是使用 <code>Promise</code> 開發的方法，因此 <code>fetch</code> 語法和 <code>Promise</code> 寫法非常類似，同時可以使用到上個章節提到的  <code>async/await</code> 。<br>​<br>本篇會使用 <code>https://randomuser.me/</code>  來做 ajax 範例。<br>​</p>
<h2 id="fetch-基本介紹"><a href="#fetch-基本介紹" class="headerlink" title="fetch 基本介紹"></a>fetch 基本介紹</h2><p>​<br>要使用 <code>fetch</code> 直接使用 <code>fetch()</code>  並帶上網址便可執行 Ajax 行為，上面有提到 <code>fetch</code> 其實就是使用 <code>Promise</code> 開發的方法，因此當 <code>fetch</code> 的 Ajax 成功後，會使用和 <code>Promise</code> 相同使用 <code>.then()</code>  來執行成功的程式碼，失敗則是使用 <code>.catch()</code>  ，比如這個範例：<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;https://randomuser.me/api/&#x27;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 回傳 ReadableStream 物件，可使用 .json() 等等方法，取得對應資料。</span></span><br><span class="line">    <span class="keyword">return</span> response.json()</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;錯誤:&#x27;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>​<br> 當 <code>fetch</code>  成功後，會回傳 <code>ReadableStream</code> 物件，這時會使用不同的方法取得對應資料，上面範例就使用 <code>json()</code>  來將 <code>ReadableStream</code> 轉換成一個實際可使用的物件， 其他方法還有：<br>​</p>
<ul>
<li>json()</li>
<li>text()</li>
<li>bolb()</li>
<li>arrayBuffer()</li>
<li>redirect()</li>
<li>clone()</li>
<li>error()</li>
</ul>
<p>詳細部分可參考 MDN 文件介紹：<a href="https://developer.mozilla.org/zh-TW/docs/Web/API/Response">https://developer.mozilla.org/zh-TW/docs/Web/API/Response</a><br>上面也有提到 <code>fetch</code> 也可以搭配  <code>async/await</code> ，以上面範例來製作 <code>async/await</code> 版本：<br>​</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">useAjax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">const</span> ajax = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://randomuser.me/api/&#x27;</span>);</span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">await</span> ajax.json();</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;錯誤:&#x27;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">useAjax()</span><br></pre></td></tr></table></figure>
<p>​</p>
<h2 id="如何設定-fetch"><a href="#如何設定-fetch" class="headerlink" title="如何設定 fetch"></a>如何設定 fetch</h2><p>​<br>在實做中 Ajax 行為往往不會向上面範例這麼簡單，通常還需要設定一些  <code>headers</code>、 <code>methods</code>  等等的設定，若要設定這些功能會在 <code>fetch()</code>  中第二個參數做詳細設定，而第二個參數必需寫成物件，比如這個範例：<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;http://httpbin.org/post&#x27;</span>, &#123;</span><br><span class="line">      <span class="comment">// Ajax 行為改為 Post</span></span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      <span class="comment">// headers 加入 json 格式</span></span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">      .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> response.json()</span><br><span class="line">      &#125;).then(<span class="function">(<span class="params">Data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(Data)</span><br><span class="line">      &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;錯誤:&#x27;</span>, err)</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>
<p>​<br>值得一提的是，使用 <code>post</code> 行為時 ，我們通常會帶上一些資料給後端，和其他包裝好的 Ajax 框架不同， <code>fetch</code>  會需要手動將資料轉成字串。<br>​</p>
<h2 id="fetch-搭配-async-await-範例"><a href="#fetch-搭配-async-await-範例" class="headerlink" title="fetch 搭配 async/await 範例"></a>fetch 搭配 async/await 範例</h2><p>​<br>在實做中一定會碰到需要有順序的執行 Ajax 的狀況，而這邊也模擬一些狀況，使用 <code>fetch</code> 做 Ajax 串接，並搭配前幾個章節介紹的 <code>async/await</code> 、 <code>Promise.all()</code> 來製作可以按順序來執行 Ajax 的程式碼：<br>​</p>
<ul>
<li>狀況一：需等 Ajax1 完成後，才執行 Ajax2<br>​<br>這種狀況使用 <code>async/await</code> 或是 原生 <code>Promise</code> 鏈式寫法都能達成，這邊以 <code>async/await</code> 為範例：<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">useAjax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ajax1 = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://randomuser.me/api/&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> data1 = <span class="keyword">await</span> ajax1.json()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;data1&#x27;</span>, data1)</span><br><span class="line">    <span class="keyword">const</span> ajax2 = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://randomuser.me/api/&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> data2 = <span class="keyword">await</span> ajax2.json();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;data2&#x27;</span>, data2)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;錯誤:&#x27;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">useAjax()</span><br></pre></td></tr></table></figure>
​</li>
<li>狀況二： 需等 Ajax1、Ajax2 完成後，才執行 Ajax3<br>​<br>這種狀況其實繼續使用  <code>async/await</code>  來寫也可以達成，不過會變成:<br>​<br>執行 Ajax1 ⇒ Ajax1 完成 ⇒ 執行 Ajax2 ⇒  Ajax2 完成 ⇒ 執行 Ajax3<br>​<br>這樣就會浪費較多時間再等待 Ajax 回傳，所以比較好的方法就是使用 <code>Promise.all()</code> 搭配 <code>async/await</code> ，或是單純 <code>Promise.all()</code> 加上 <code>Promise</code> 鏈式寫法，這邊以 <code>Promise.all()</code> 搭配 <code>async/await</code>  為範例。<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">useAjax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ajax1 = fetch(<span class="string">&#x27;https://randomuser.me/api/&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> ajax2 = fetch(<span class="string">&#x27;https://randomuser.me/api/&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> [res1, res2] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([ajax1, ajax2])</span><br><span class="line">    <span class="keyword">const</span> data1 = <span class="keyword">await</span> res1.json()</span><br><span class="line">    <span class="keyword">const</span> data2 = <span class="keyword">await</span> res2.json()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;data1&#x27;</span>, data1)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;data2&#x27;</span>, data2)</span><br><span class="line">    <span class="keyword">const</span> ajax3 = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://randomuser.me/api/&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> data3 = <span class="keyword">await</span> ajax3.json()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;data3&#x27;</span>, data3)</span><br><span class="line">  &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;錯誤:&#x27;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">useAjax()</span><br></pre></td></tr></table></figure>
​<br>​<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2></li>
<li><a href="https://wcc723.github.io/javascript/2017/12/28/javascript-fetch/">鐵人賽：ES6 原生 Fetch 遠端資料方法</a></li>
<li> <a href="https://developer.mozilla.org/zh-TW/docs/Web/API/Fetch_API/Using_Fetch#response_objects">MDN 文件 - fetch</a><br>​</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day27) ESM 模組化拆檔</title>
    <url>/2021/10/03/JS-core/(Day27)%20ESM%20%E6%A8%A1%E7%B5%84%E5%8C%96%E6%8B%86%E6%AA%94/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>隨者前端需求越來越多，前端工程師在管理程式碼上的需求也越來越重，幸好 ES6 引入時 JavaScript 有引入的 ESM 的拆檔功能，以方便開發者管理程式碼，而目前大多數的 JavaScript  套件也有都使用到 ESM 的方法來做開發以及管理，算是前端工程師必學的方法之一了，而 ESM 他的全名是「ES6 Modules or JavaScript Modules」。</p>
<h2 id="ESM-基本介紹"><a href="#ESM-基本介紹" class="headerlink" title="ESM 基本介紹"></a>ESM 基本介紹</h2><p>如果要使用 ESM 的模組化，首先必需在 <code>&lt;script&gt;</code> 標籤添加 <code>type=&quot;module&quot;</code>  這樣 JavaScript 變能使用模組化的功能，而這個就模組功能，簡單來說就是使用 <code>export</code>  來做匯出動作 、 <code>import</code> 來做匯入動作，而匯出和匯入大致可分成：</p>
<ul>
<li>預設匯出、預設匯入</li>
<li>具名匯出、具名匯入</li>
</ul>
<p>由於 預設匯出 一定會搭配 預設匯入 ，具名匯出 一定會搭配 具名匯入 因此接下來就來講講這兩種狀況:</p>
<h2 id="具名匯出、具名匯入"><a href="#具名匯出、具名匯入" class="headerlink" title="具名匯出、具名匯入"></a>具名匯出、具名匯入</h2><h3 id="具名匯出"><a href="#具名匯出" class="headerlink" title="具名匯出"></a>具名匯出</h3><p>故名思義具名匯出，就會是以有名稱的方式將資料匯出，具名匯出在同一個 JS 檔案上，並沒有限制，可以同一個 JavaScript 檔案匯出多此，具名匯出則大致可分為以下幾種：</p>
<ol>
<li> <code>export</code> 後使用 <code>let</code>、<code>const</code> 宣告:</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> str = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>export</code> 後使用函式陳述式:</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;具名匯出&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>將變數資料整合起來使用以物件縮寫方式，統一匯出:</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;具名匯出&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> obj = &#123;</span><br><span class="line">str, array, fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具名匯入"><a href="#具名匯入" class="headerlink" title="具名匯入"></a>具名匯入</h3><p>由於具名匯出以經帶有名稱了，因此當我們使用 具名匯入 時，匯入的名稱，會是 和具名匯出 時相同的名稱來做匯入動作，而具名匯入一般狀況會是 <code>import &#123; ... &#125; form &#39;./app.js&#39;</code> 的方式匯入。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  具名匯出檔案 app.js */</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;具名匯出&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> obj = &#123;</span><br><span class="line">str, array, fn</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> number = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名匯入檔案</span></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">import</span> &#123; obj , number &#125; <span class="keyword">from</span> <span class="string">&#x27;./app.js&#x27;</span> </span><br><span class="line">    <span class="built_in">console</span>.log(obj, number)  <span class="comment">// obj: &#123; str: &quot;test&quot;, array:[1,2,3] , fn: fn() &#125; , 123</span></span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>而具名匯入後其實可以更改名稱的，會使用 <code>as</code>  來將具名匯入的檔案更改名稱：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">import</span> &#123; obj ,  number <span class="keyword">as</span> num &#125; <span class="keyword">from</span> <span class="string">&#x27;./app.js&#x27;</span> <span class="comment">// 將 number 改為 num</span></span><br><span class="line">    <span class="built_in">console</span>.log(obj, num )  <span class="comment">// obj: &#123; str: &quot;test&quot;, array:[1,2,3] , fn: fn() &#125; , 123</span></span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>同時具名匯入也可以一口氣匯入所有資料，會使用  <code>*</code> 字號時，搭配 <code>as</code> 將匯入的資料，賦予到一個新的變數叫做 <code>app</code> 上，不過實做中這種一口氣匯入寫法通常較少用到：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">import</span>  * <span class="keyword">as</span> app  <span class="keyword">from</span> <span class="string">&#x27;./app.js&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(app.obj, app.number )  <span class="comment">// obj: &#123; str: &quot;test&quot;, array:[1,2,3] , fn: fn() &#125; , 123</span></span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="預設匯出、預設匯入"><a href="#預設匯出、預設匯入" class="headerlink" title="預設匯出、預設匯入"></a>預設匯出、預設匯入</h2><h3 id="預設匯出"><a href="#預設匯出" class="headerlink" title="預設匯出"></a>預設匯出</h3><p>當匯出部分使用 <code>export default</code>  就可以知道這組是使用 預設匯出 與 預設匯入，預設匯出同樣可以匯出任何資料，字串、陣列、函式，最常見的就會是匯出一個物件，但是無法使用 變數/常數 的形式來匯出，而每個一個 JS 檔，只能使用一次預設匯出。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* app.js */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">str</span> : <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">  <span class="attr">array</span> : [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  <span class="function"><span class="title">fn</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;預設匯出&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="預設匯入"><a href="#預設匯入" class="headerlink" title="預設匯入"></a>預設匯入</h3><p>由於預設匯出時，並沒有使用任何名稱，因此匯入時並需使用一個名稱來接收資料</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> app <span class="keyword">from</span> <span class="string">&#x27;./app.js&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(app.str) <span class="comment">// test</span></span><br><span class="line"><span class="built_in">console</span>.log(app.array) <span class="comment">// [1,2,3]</span></span><br><span class="line">app.fn() <span class="comment">// 預設匯出</span></span><br></pre></td></tr></table></figure>

<h2 id="同時匯入預設、具名"><a href="#同時匯入預設、具名" class="headerlink" title="同時匯入預設、具名"></a>同時匯入預設、具名</h2><p>匯出時可同時使用預設匯出、具名匯出，而匯入部分要同時使用兩種匯入方法也是 OK 的，不過要使用這種方法，使用上會有個固定的格式。<br>需要同時使用兩種引入方式時，<code>import</code> 會先寫入預設匯入部分，設定好後，自定義名稱後方會用上逗號將 預設匯入 、具名匯入的名稱分開，而逗號後方會是 <code>* as xxx</code> 來將具名匯入一口氣匯入進來。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  匯出檔案 app.js */</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;具名匯出&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> obj = &#123;</span><br><span class="line">str, array, fn</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>   <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匯入檔案</span></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">import</span> number , * <span class="keyword">as</span> obj  <span class="keyword">from</span> <span class="string">&#x27;./app.js&#x27;</span> <span class="comment">// number 是預設匯入， obj 則是具名匯入。 </span></span><br><span class="line">    <span class="built_in">console</span>.log(obj, number)  <span class="comment">// obj: &#123; str: &quot;test&quot;, array:[1,2,3] , fn: fn() &#125; , 123</span></span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="使用-type-module-後的變化"><a href="#使用-type-module-後的變化" class="headerlink" title="使用 type= module 後的變化"></a>使用 type= module 後的變化</h2><p>而最後也在補充一下，當我們在  <code>&lt;script&gt;</code> 標籤添加 <code>type= module</code>  後其實 JavaScript 會發生一些變化，如下:</p>
<ul>
<li>各個 Script 作用域獨立：<br>在原本 JavaScript 中是可以跨  <code>&lt;script&gt;</code>  標籤來做資料存取動作，比如：</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&#x27;Ryder&#x27;</span>;</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line">  </span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="built_in">console</span>.log(name); <span class="comment">// Ryder</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p> 如果在  <code>&lt;script&gt;</code> 標籤添加 <code>type= module</code>  後  <code>&lt;script&gt;</code> 標籤的作用域都會被獨立，是無法在取得另一個  <code>&lt;script&gt;</code>  標籤的資料，比如：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&#x27;Ryder&#x27;</span>;</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line">  </span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="built_in">console</span>.log(name); <span class="comment">// ReferenceError: name is not defined</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>開啟嚴格模式</li>
</ul>
<p>在 this 章節有提到 簡易呼叫 的 <code>this</code> 會指向 window，但當我們在  <code>&lt;script&gt;</code> 標籤添加 <code>type= module</code>  後，因為嚴格模式開啟 簡易呼叫的 <code>this</code>  會從 window 變為 undefined</p>
<p>使用前：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line">fn() </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用後：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line">fn() </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ul>
<li>JavaScript 核心篇 (六角學院)</li>
<li><a href="https://hsiangfeng.github.io/javascript/20210424/616364031/">什麼是 ESM(ES6 Modules or JavaScript Modules) 呢？</a></li>
<li><a href="https://wcc723.github.io/development/2020/03/25/import-export/">完全解析 JavaScript import、export</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day28) ES6 展開運算子與其餘參數</title>
    <url>/2021/10/03/JS-core/(Day28)%20ES6%20%E5%B1%95%E9%96%8B%E9%81%8B%E7%AE%97%E5%AD%90%E8%88%87%E5%85%B6%E9%A4%98%E5%8F%83%E6%95%B8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>展開運算子與其餘參數是 ES6 新增的兩個特性，使用上都一樣是 <code>...</code>  也就是三個點，不過實際上這兩個方法代表的意義會不太一樣，接下來一一介紹。<br>​</p>
<h2 id="展開運算子-Spread-syntax"><a href="#展開運算子-Spread-syntax" class="headerlink" title="展開運算子 (Spread syntax)"></a>展開運算子 (Spread syntax)</h2><p>​<br>展開運算子是主要用在陣列上的運算子，在實做中這個方法其實滿常用的，而他的概念正如名稱一樣，將資料展開，並且一一取得該陣列的值，在過去若想將陣列資料傳至另一個陣列資料時，我們會使用  <code>.contant()</code> 方法比如：<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>];</span><br><span class="line">array1 = array1.concat(array2)</span><br><span class="line"><span class="built_in">console</span>.log(array1)</span><br></pre></td></tr></table></figure>
<p>​<br>要達成這個需求，現在則可以使用展開運算子達成：<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ];</span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>];</span><br><span class="line">array1 =  [...array1, ...array2]</span><br><span class="line"><span class="built_in">console</span>.log(array1) <span class="comment">//(6) [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>​<br>這樣看或許還對這個功能感到有些模糊，這時直接使用 <code>console.log( ...array1 )</code>  ，變可以明白他其實就是將陣列中的值一一的使用並 <code>return</code> 出來。<br>​</p>
<h3 id="淺層複製"><a href="#淺層複製" class="headerlink" title="淺層複製"></a>淺層複製</h3><p>​<br>從上面說明也可以明白，展開運算子，也可用於複製陣列上，若使用 展開運算子 複製陣列時他是屬於淺層複製的一種，如果是淺層複製的陣列，他們第一層的參考會是不同的，也就是不會影響原始物件，例如：<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ]</span><br><span class="line"><span class="keyword">var</span> array2 = [ ... array1 ]</span><br><span class="line">array2.push(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(array1)  <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>​<br>而非淺層複製就會使用共同參考:<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ]</span><br><span class="line"><span class="keyword">var</span> array2 = array1</span><br><span class="line">array2.push(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(array1)  <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>​<br>上面範例雖然都用在陣列上，但其實如果只是要使用複製功能，物件也能使用這個方法，例如：<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">name1</span>:<span class="string">&#x27;Ryder&#x27;</span>, <span class="attr">name2</span>:<span class="string">&#x27;Jack&#x27;</span>, <span class="attr">name3</span>:<span class="string">&#x27;Annie&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; ...obj1 &#125;</span><br><span class="line"><span class="built_in">console</span>.log( obj2 ) <span class="comment">// &#123; name1:&#x27;Ryder&#x27;, name2:&#x27;Jack&#x27;, name3:&#x27;Annie&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<p>​</p>
<h3 id="類陣列轉成純陣列"><a href="#類陣列轉成純陣列" class="headerlink" title="類陣列轉成純陣列"></a>類陣列轉成純陣列</h3><p>​<br>展開運算子還有一個功能，就是將類陣列轉換成純陣列，JS 某些語法會創造出的類陣列（非完全陣列沒有完整的陣列原型），例如<br>​</p>
<ul>
<li>函式中的 <code>arguments</code> 參數：<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="built_in">console</span>.log( [...arguments] )</span><br><span class="line">&#125;</span><br><span class="line">Fn1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
​</li>
<li><code>document.querySelectorAll()</code>  等等的取得 DOM 元素的方法：<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buttons = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log( buttons )</span><br><span class="line"><span class="built_in">console</span>.log( [...buttons] )</span><br><span class="line">​</span><br></pre></td></tr></table></figure>
​<h2 id="其餘參數-rest-parameter"><a href="#其餘參數-rest-parameter" class="headerlink" title="其餘參數 (rest parameter)"></a>其餘參數 (rest parameter)</h2>​<br>若要使用其餘參數，我們可以在函式參數打上 <code>...arg</code> (名稱可自訂），這樣便是使用其餘參數的功能。<br>上面剛好有提到，函式的  <code>arguments</code> 參數，而其餘參數其實就跟 <code>arguments</code> 參數非常相像，就是將所有參數，使用陣列包起來呈現，而這兩個寫法主要差別有兩點：<br>​</li>
<li><code>arguments</code> 是類陣列、其餘參數 是真正的陣列。</li>
<li>有寫上自定義參數時 <code>arguments</code>  並不會自動配合參數給予剩餘值，而其餘參數寫法會自動調配。<br>​<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其餘參數，顯示剩餘參數的所有值。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params"> num, ...arg  </span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num, arg) <span class="comment">// 1 , [2, 3]</span></span><br><span class="line">&#125;</span><br><span class="line">Fn1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">​</span><br><span class="line"><span class="comment">// arguments 只會顯示該函式所有參數，不會自動調配。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn2</span>(<span class="params"> num, ...arg  </span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num, arg) <span class="comment">// 1  [1, 2, 3]</span></span><br><span class="line">&#125;</span><br><span class="line">Fn2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">​</span><br></pre></td></tr></table></figure>
​<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2></li>
<li><a href="https://wcc723.github.io/javascript/2017/12/24/javascript-spread-operator/">鐵人賽：JavaScript 展開與其餘</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day29) ES6 - 解構賦值</title>
    <url>/2021/10/03/JS-core/(Day29)%20ES6%20-%20%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​<br>解構賦值是 ES6 新增語法糖，若要使用陣列、物件中的值，來見新的變數/常數，可以使用解構賦值的方法，來快速建立。<br>​</p>
<h2 id="陣列解構"><a href="#陣列解構" class="headerlink" title="陣列解構"></a>陣列解構</h2><p>​<br>陣列解構主要是根據陣列中的順序，再對應的順序建立變數/常數，便可直接獲得陣列中的值。<br>比如過去要獲得陣列的值會這樣寫：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> a = array[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> b = array[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>​<br>而現在可使用解構：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a,b] = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 1, 2</span></span><br></pre></td></tr></table></figure>
<p>​<br>關於陣列解構還有其他特殊用法，這邊舉出幾個較容易使用到的：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先建立變數，後賦值</span></span><br><span class="line"><span class="keyword">let</span> a, b</span><br><span class="line">[a, b] = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a,b) <span class="comment">// 1, 2</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">//搭配展開運算子</span></span><br><span class="line"><span class="keyword">const</span> [ a, b, ...c ] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a,b) <span class="comment">// 1, 2, [3, 4, 5]</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">// 跳過部分值</span></span><br><span class="line"><span class="keyword">const</span> [a, ,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a,c) <span class="comment">//1, 3</span></span><br></pre></td></tr></table></figure>
<p>​</p>
<h2 id="物件解構"><a href="#物件解構" class="headerlink" title="物件解構"></a>物件解構</h2><p>​<br>物件要使用解構會和陣列不同，陣列主要是按照順序獲得值，而物件要使用解構則是要讓，變數名稱和物件屬性一致才可以取得物件的值，比如：<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> school = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Taipei University&#x27;</span>,  </span><br><span class="line">    <span class="attr">classes</span>: &#123; </span><br><span class="line">        <span class="attr">teacher</span>: <span class="string">&#x27;Alex&#x27;</span>,</span><br><span class="line">        <span class="attr">student</span>:[<span class="string">&#x27;Kevin&#x27;</span>,<span class="string">&#x27;Clara&#x27;</span>,<span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; teacher, student &#125; = school.classes</span><br></pre></td></tr></table></figure>
<p>​<br>上面範例就是透過解構，直接將 <code>school.classes</code> 中的 <code>teacher</code> 、 <code>student</code>  屬性中的值變成對應的常數，由於我們現在很常會使用到 Ajax 來獲得後端傳來的物件，因此這個寫法使到頻率其實滿高的，而當然物件解構也有一些特殊用法，這邊舉出幾個較容易使用到的：<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">​</span><br><span class="line"><span class="comment">// 使用 : 替換解構賦值的名稱，讓變數/常數改為新名稱。</span></span><br><span class="line"><span class="keyword">const</span> school = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Taipei University&#x27;</span>,  </span><br><span class="line">    <span class="attr">classes</span>: &#123; </span><br><span class="line">        <span class="attr">teacher</span>: <span class="string">&#x27;Alex&#x27;</span>,</span><br><span class="line">        <span class="attr">student</span>:[<span class="string">&#x27;Kevin&#x27;</span>,<span class="string">&#x27;Clara&#x27;</span>,<span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: schoolName &#125; = school </span><br><span class="line"><span class="built_in">console</span>.log(schoolName) <span class="comment">// Taipei University</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">// 使用 展開運算子 解構物件</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>, <span class="attr">c</span>:<span class="number">3</span>, <span class="attr">d</span>:<span class="number">4</span>, <span class="attr">e</span>:<span class="number">5</span> &#125;</span><br><span class="line"><span class="keyword">const</span> &#123; a,b,...arg &#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(a,b,arg) <span class="comment">//1, 2, &#123;c: 3, d: 4, e: 5&#125;</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">// 透過函式參數解構物件，獲得物件中的值。</span></span><br><span class="line"><span class="keyword">const</span> school = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Taipei University&#x27;</span>,  </span><br><span class="line">    <span class="attr">classes</span>: &#123; </span><br><span class="line">        <span class="attr">teacher</span>: <span class="string">&#x27;Alex&#x27;</span>,</span><br><span class="line">        <span class="attr">student</span>:[<span class="string">&#x27;Kevin&#x27;</span>,<span class="string">&#x27;Clara&#x27;</span>,<span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTeacher</span>(<span class="params">&#123; classes : &#123; teacher &#125;&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> teacher </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getTeacher(school)) <span class="comment">//Alex</span></span><br></pre></td></tr></table></figure>
<p>​</p>
<h2 id="解構賦值預設值"><a href="#解構賦值預設值" class="headerlink" title="解構賦值預設值"></a>解構賦值預設值</h2><p>而解構賦值其實也和函式參數一樣，也能設定預設值，不論是物件見或是陣列，都可以使用 <code>=</code>  運算子，為解構賦值新增的變數/常數 設定預設值，以避免解構賦值時沒有正確獲得值。<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//未解構賦值設定預設值</span></span><br><span class="line"><span class="keyword">const</span> [a, b, c = <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) <span class="comment">// 1, 2, 3https://ithelp.ithome.com.tw/articles/10274861/draft</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> school = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Taipei University&#x27;</span>,  </span><br><span class="line">    <span class="attr">classes</span>: &#123; </span><br><span class="line">        <span class="attr">teacher</span>: <span class="string">&#x27;Alex&#x27;</span>,</span><br><span class="line">        <span class="attr">student</span>:[<span class="string">&#x27;Kevin&#x27;</span>,<span class="string">&#x27;Clara&#x27;</span>,<span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; teacher ,student , address = <span class="string">&#x27;新北市三峽區大學路151號&#x27;</span> &#125; = school.classes</span><br></pre></td></tr></table></figure>
<p>​</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ul>
<li><a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/destructuring.html">解構賦值</a></li>
<li><a href="https://wcc723.github.io/javascript/2017/12/25/javascript-destructuring/">鐵人賽：ES6 解構賦值</a><br>​<br>​</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day 19) 原型與建構式</title>
    <url>/2021/10/03/JS-core/(Day19)%20%E5%8E%9F%E5%9E%8B%E8%88%87%E5%BB%BA%E6%A7%8B%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="函式建構式建立原型"><a href="#函式建構式建立原型" class="headerlink" title="函式建構式建立原型"></a>函式建構式建立原型</h2><p>​<br>前面幾篇有提到，可以使用函示建構式、或是 ES 6 來建立原型，今天就來介紹使用 函示建構式 來建立原型。<br>​<br>首先便是建立一個函示建構式<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函示建構式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TShirt</span>(<span class="params">color,material,size</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color = color</span><br><span class="line">    <span class="built_in">this</span>.material = material</span><br><span class="line">    <span class="built_in">this</span>.size = size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​<br>雖然是函式但我們不會使用直些使用  <code>Tshirt()</code>  來呼叫這個函式，而是會搭配 <code>new</code> 來製作實體資料 ，使用 <code>new</code>  這個運算子製作出來的都一定會是物件。<br>​<br>當使用 <code>new</code>  製作新物件時，函式建構式中的 <code>this</code>  則會指向這個新物件本身，因此上方範例中的 <code>color</code> 、<code>material</code> 、 <code>size</code>  接下來都會變成物件中的屬性，並且在根據參數設定，讓物件中屬性有不同的值，這邊就夠過 <code>new</code> 搭配參數，來讓新增一個 <code>BlackTShit</code> 物件：<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">​</span><br><span class="line"><span class="keyword">const</span> BlackTShit = <span class="keyword">new</span> TShirt(<span class="string">&#x27;black&#x27;</span>,<span class="string">&#x27;棉&#x27;</span>,<span class="string">&#x27;L&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>​<br>這樣便是使用 <code>TShirt</code> 這個函示建構式來製作 <code>BlackTShit</code>  物件，將 <code>BlackTShit</code>  的  <code>[[Prototype]]</code> 點開後會發現一般建立變數時都沒有的 <code>constructor</code>  屬性，如圖<br>​<br><img src="https://i.imgur.com/jsnfGfy.png"><br>​<br>這是因為 <code>BlackTShit</code>  是使用函示建構式製作，當這筆物件使用建構函示製作時，他的原型就會是 <code>constructor</code> ，並且也可以看到 <code>constructor</code>  指向的是 <code>TShirt</code> 這個函示。<br>​</p>
<h2 id="建立原型的方法"><a href="#建立原型的方法" class="headerlink" title="建立原型的方法"></a>建立原型的方法</h2><p>​<br>這樣變完成一個簡單的原型鍊，不過想在原型中新增方法，是無法直接寫在函示建構式上，這邊會需要使用 <code>prototype</code>  來製作的原型方法，繼續以 <code>TShirt</code>  為例就會是：<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">TShirt.prototype.clothe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`穿上 <span class="subst">$&#123;<span class="built_in">this</span>.color&#125;</span> T Shit`</span>);</span><br><span class="line">&#125;</span><br><span class="line">BlackTShit.clothe() <span class="comment">// 穿上 black T Shit</span></span><br></pre></td></tr></table></figure>
<p>​<br>這時在使用 <code>TShirt</code> 製作一個新的實體資料，來確認 <code>clothe()</code>  這個原型方法其他實體是否能使用。<br>​</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> darkBlueTShit= <span class="keyword">new</span> TShirt(<span class="string">&#x27;darkBlue&#x27;</span>,<span class="string">&#x27;聚酯纖維&#x27;</span>,<span class="string">&#x27;XL&#x27;</span>)</span><br><span class="line">darkBlueTShit.clothe() <span class="comment">// 穿上 darkBlue T Shit</span></span><br></pre></td></tr></table></figure>
<p>​<br>另外這邊要補充一點：當我們使用對建構函示的名稱使用 <code>.prototype</code> 他會回傳 <code>constructor</code> ，而這個 <code>constructor</code> 其實指向自己這個建構函示，以本次範例來說就是使用  <code>TShirt.prototype</code> 回傳的 <code>constructor</code>  就是指向 <code>TShirt</code> 建構函式自己，這點雖然根本次文章無關，但是在後續製作多層原型時會有使用到此觀念，於是這邊先補充了。<br>​<br><img src="https://i.imgur.com/FLKOnuR.png"><br>​<br>最後要提的一點 <code>[[prototype]]</code>與 <code>prototype</code> 差別 ：<br>​</p>
<ul>
<li><code>[[prototype]]</code> 物件上使用 ( chrome瀏覽器更新現在看到的是 <code>[[prototype]]</code> ，以前的是 <code>__proto__</code> 兩者差異先前的文章有提到：</li>
<li><code>prototype</code> 函式上使用<br>​<br><code>[[prototype]]</code> 在 JS 中，幾乎所有資料都有 <code>[[prototype]]</code>，是用來連接原型的，不過他並不是真正的一個屬性，因此又被稱做 『隱式原型』 implicit prototype link 。<br>​<br><code>[[prototype]]</code>  正是因為所有資料都有這個屬性，因此直接使用 <code>__proto__</code>  去做修改會導致程式碼管理上困難。<br>​<br>而  <code>prototype</code>  則只有函示上會顯示，因此若要實際為原型添加方法，會選擇使用 <code>prototype</code>  去新增。<br>​<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2></li>
<li>JavaScript 核心篇 (六角學院）</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day05) 原始型別及物件型別</title>
    <url>/2021/10/01/JS-core/(Day05)%20%E5%8E%9F%E5%A7%8B%E5%9E%8B%E5%88%A5%E5%8F%8A%E7%89%A9%E4%BB%B6%E5%9E%8B%E5%88%A5/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 JavaScript  這語言裡，其實指分成兩種型別：原始型別、物件型別，接下來變來介紹這些型別與之對應的資料。</p>
<h2 id="原始型別"><a href="#原始型別" class="headerlink" title="原始型別"></a>原始型別</h2><p>原始型別又稱純值，在 JS 世界中除了 7 種原始型別，其他的都是<strong>物件型別</strong>，所以這邊先來認識一下有哪些屬於原始型別：</p>
<ul>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
<li>Null</li>
<li>Undefined</li>
</ul>
<p>以及後來新增的兩種原始型別：</p>
<ul>
<li>Biglnt</li>
<li>Symbol</li>
</ul>
<p>使用  <code>typeof()</code>  這個方法可以查詢變數、常數的型別，比較特別的是 查詢 <code>null</code> 會回傳 object ，這是 JS 長久以來存在的 bug，由於修正了會有許多老舊網站無法運作，於是他變一直存在。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span>(string) <span class="comment">// &quot;string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">1232</span></span><br><span class="line"><span class="keyword">typeof</span>(num) <span class="comment">//&quot;number&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boolean = <span class="literal">true</span></span><br><span class="line"><span class="keyword">typeof</span>(boolean) <span class="comment">//&quot;boolean&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unde = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">typeof</span>(unde) <span class="comment">//&quot;undefined&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nu = <span class="literal">null</span> </span><br><span class="line"><span class="keyword">typeof</span>(nu) <span class="comment">//object</span></span><br></pre></td></tr></table></figure>

<p>值得一提的是這些原始型別，都有一些能夠使用的特別方法，例如 </p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string1 = <span class="string">&#x27;test&#x27;</span></span><br><span class="line">string1.length <span class="comment">//4</span></span><br><span class="line">string1.toUpperCase() <span class="comment">// TEST</span></span><br></pre></td></tr></table></figure>

<p>之所以這些原始型別能夠使用這些方法，是因為當我們對 原始型別的資料 使用這些方法時，原始型別會夠透過 <strong>基本型別包裹器(Primitive Wrapper)</strong>  將 原始型別資料 暫時轉換成 帶有這些 特殊方法的 物件。</p>
<p>實際上我們可以直接使用  <code>new</code>  的建構式方法，來建立轉換後的資料，並且對使用 <code>new</code> 建構式建立的資料 使用 <code>typeof</code> 來做他都會回傳 Object，也因為這個特性我們實做時不太會使用這種方法建立相關資料。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="keyword">typeof</span> string2 <span class="comment">//object </span></span><br></pre></td></tr></table></figure>

<p>在瀏覽器輸入 string2 除了會回傳我們建立的資料，還有一個  <code>[[Prototype]]</code> （原型）欄位，將他點開會發現 該型別能使用的特別方法都藏在這裡：<br><img src="https://i.imgur.com/FlsSUrI.png"></p>
<p>（原型以及建構式，在後續原型章節則會再介紹到。）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>();</span><br><span class="line"><span class="built_in">BigInt</span>();</span><br><span class="line"><span class="built_in">Symbol</span>();</span><br></pre></td></tr></table></figure>

<p>唯獨 undefined 以及 null 是沒有基本型別包裹器。</p>
<h2 id="物件型別"><a href="#物件型別" class="headerlink" title="物件型別"></a>物件型別</h2><p>除了上面 7 種原始，其他都屬於物件型別，這邊也介紹一下常用到的物件型別。</p>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>陣列也是屬於物件型別的一種，這邊使用上面提到的 <code>typeof()</code>  就能確認這點</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">typeof</span>(array ) <span class="comment">//object</span></span><br></pre></td></tr></table></figure>

<h3 id="函示"><a href="#函示" class="headerlink" title="函示"></a>函示</h3><p>函示也是物件型別的一種，使用 <code>typeof(function test())</code> 他會回傳 “function” ，但函示其實是比較特別的物件，被稱做『函式物件 ( Function Object )』， 這點 MDN 文件也有提到：</p>
<blockquote>
<p>Function 建構函式可建立一個新的 Function 物件。在 JavaScript 中，所有的函式實際上都是 Function 物件。</p>
</blockquote>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><p>JavaScript 核心篇 (六角學院）</p>
</li>
<li><p><a href="https://hsiangfeng.github.io/javascript/20200621/3684249269/">JavaScript 核心觀念(14)-運算子、型別與文法-原始型別及物件型別</a></p>
</li>
<li><p><a href="https://ithelp.ithome.com.tw/articles/10193902">重新認識 JavaScript: Day 23 基本型別包裹器 Primitive Wrapper</a></p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function">MDN 文件 - Function</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day06) 強制轉型 &amp; 顯性轉型</title>
    <url>/2021/10/02/JS-core/(Day06)%20%E5%BC%B7%E5%88%B6%E8%BD%89%E5%9E%8B%20&amp;%20%E9%A1%AF%E6%80%A7%E8%BD%89%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="動態型別"><a href="#動態型別" class="headerlink" title="動態型別"></a>動態型別</h2><p>前面有介紹 JavaScript  資料分成七種原始型別以及物件型別，關於型別 JavaScript 有一種廣為人知的特性：動態型別。</p>
<p>JavaScript 之所以會是動態行別，就要提到到實做中 JavaScript 最容易碰上的底層問題之一 『強制轉型』，而 強制轉型 又分成兩種</p>
<ul>
<li>顯性轉型 ( Explicit  Conversion ) ，故名思義就是我們實際在程式碼中，會看有明確對變數執行轉型動作。</li>
<li>隱含轉型 ( Implicit Conversion )，和上顯性轉型與之相反概念，就是看不到單從程式碼，在程式碼上沒看到轉型動作，但 JavaScript 中偷偷幫你轉型的方法。</li>
</ul>
<p>今天就會介紹大致上有哪些語法是顯性轉型，下篇則會再介紹隱含轉型。</p>
<p>而這兩種術語並沒有特別明確的規範，他只是相對上的術語，因此有些狀況看起來是 ：似隱似顯的 但其實不用太糾結是分類在哪種，知道如何使用就沒有問題了，兩種轉型範例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test1 = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">test1 = <span class="built_in">Number</span>(test1 )<span class="comment">//顯性轉型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test2 = <span class="number">456</span></span><br><span class="line">test2 = test2 + <span class="string">&#x27;1&#x27;</span> <span class="comment">//隱性轉型</span></span><br></pre></td></tr></table></figure>

<h2 id="顯性轉型"><a href="#顯性轉型" class="headerlink" title="顯性轉型"></a>顯性轉型</h2><p>在 『你不懂 JS』一書中是將顯性轉型分成以下三種: </p>
<ul>
<li>顯性轉型 ： Strings &lt;–&gt; Numbers</li>
<li>顯性轉型 ：数字字符串</li>
<li>顯性轉型 ：Boolean</li>
</ul>
<p>『你不懂 JS』一書這種分法確實比較全面，但對我們這些腦袋比較簡單的人來說，反而不好理解，這邊試者改成比較容易理解三種：</p>
<ul>
<li>顯性轉型 ：轉成 String</li>
<li>顯性轉型 ：轉成 Number</li>
<li>顯性轉型 ：轉成 Boolean</li>
</ul>
<p>這邊也在根據上面三種分類，稍微說明有哪些語法。</p>
<h3 id="轉成-String"><a href="#轉成-String" class="headerlink" title="轉成 String"></a>轉成 String</h3><ul>
<li>使用 <code>String()</code> 方法</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test3 = <span class="number">123</span></span><br><span class="line">test = <span class="built_in">String</span>(test3)</span><br><span class="line"><span class="keyword">typeof</span>(test3 ) <span class="comment">// &#x27;123&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>陣列原型的 <code>toString()</code></li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">&quot;R&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;r&quot;</span>]</span><br><span class="line"><span class="keyword">var</span> test4 = array.toString() <span class="comment">//&#x27;R,y,d,e,r&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="轉成-Number"><a href="#轉成-Number" class="headerlink" title="轉成 Number"></a>轉成 Number</h3><ul>
<li>使用 <code>Number()</code>  、 <code>parseInt()</code> 方法</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="keyword">var</span> test5 = <span class="built_in">Number</span>(string) <span class="comment">//123</span></span><br><span class="line"><span class="keyword">var</span> test6 = <span class="built_in">parseInt</span>(string) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 使用一元正/負運算子 <code>+</code>、<code>-</code></li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="keyword">var</span> test7 = + string <span class="comment">//123</span></span><br></pre></td></tr></table></figure>

<p>不過這種方法確實容易跟 二元運 算術運算子的 <code>＋</code> 、 <code>-</code>  寫法搞混，也因此實做確實比較少看到這種寫法。</p>
<h3 id="轉成-Boolean"><a href="#轉成-Boolean" class="headerlink" title="轉成 Boolean"></a>轉成 Boolean</h3><ul>
<li>使用 <code>Boolean()</code> 方法</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="keyword">var</span> array =[]</span><br><span class="line"><span class="keyword">var</span> number = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> not = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> boolean1 = <span class="built_in">Boolean</span>(string) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> boolean2 = <span class="built_in">Boolean</span>(array) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> boolean3 = <span class="built_in">Boolean</span>(number) <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> boolean4 = <span class="built_in">Boolean</span>(not)<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>以上大概就是常見的顯性轉型，值得一提的是使用 <code>new String()</code>、<code>new Number()</code> 等等的 <code>new</code> 建構式方法他們並不算在強制轉型的範疇中，因為這些建構式製作出來的都會物件型別的資料。</p>
<p>當然還有一種狀況是，將變數的值調整成另一種型別的值，這種作法，也是屬於顯性轉換的一種，不過這部分一看就知道，因此上述都沒有特別提出來，例如：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test8 = <span class="number">123</span></span><br><span class="line">test8 = <span class="string">&#x27;test&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li>JavaScript 核心篇 (六角學院）</li>
<li><a href="https://cythilya.github.io/2018/10/15/coercion/#tonumber">你懂 JavaScript 嗎？#8 強制轉型（Coercion）</a></li>
<li><a href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/types%20%26%20grammar/ch4.md">你不懂 JS：类型与文法</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
  <entry>
    <title>(Day30) - 目錄與完結心得</title>
    <url>/2021/10/03/JS-core/(Day30)%20-%20%E7%9B%AE%E9%8C%84%E8%88%87%E5%AE%8C%E7%B5%90%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h2 id="目錄"><a href="#目錄" class="headerlink" title="目錄"></a>目錄</h2><ul>
<li><p><a href="https://rider159159.github.io/2021/10/01/JS-core/(Day01)%20%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83%E8%88%87%E5%9F%B7%E8%A1%8C%E5%A0%86%E7%96%8A/">(Day01) 執行環境與執行堆疊</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/01/JS-core/(Day02)%20%E7%AF%84%E5%9C%8D%E9%8D%8A%E8%88%87%E6%8F%90%E5%8D%87/">(Day02) 範圍鍊與提升</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/01/JS-core/(Day03)%20%E5%9F%B7%E8%A1%8C%E7%B7%92%20%E8%88%87%20%E5%90%8C%E6%AD%A5%20&%20%E9%9D%9E%E5%90%8C%E6%AD%A5/">(Day03) 執行緒 與 同步 &amp; 非同步</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/01/JS-core/(Day04)%20%E9%99%B3%E8%BF%B0%E5%BC%8F&%E8%A1%A8%E9%81%94%E5%BC%8F/">(Day04) 陳述式 &amp; 表達式 </a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/01/JS-core/(Day05)%20%E5%8E%9F%E5%A7%8B%E5%9E%8B%E5%88%A5%E5%8F%8A%E7%89%A9%E4%BB%B6%E5%9E%8B%E5%88%A5/">(Day05) 原始型別及物件型別 </a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/02/JS-core/(Day06)%20%E5%BC%B7%E5%88%B6%E8%BD%89%E5%9E%8B%20&%20%E9%A1%AF%E6%80%A7%E8%BD%89%E5%9E%8B/">(Day06) 強制轉型 &amp; 顯性轉型</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/02/JS-core/(Day07)%20%E9%9A%B1%E5%90%AB%E8%BD%89%E5%9E%8B-%E5%81%B7%E5%81%B7%E8%BD%89%E6%8F%9B%E7%9A%84%20Strings%20%E8%88%87%20Numbers%20%E9%A1%9E%E5%9E%8B/">(Day07) 隱含轉型-偷偷轉換的 Strings 與 Numbers 類型</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/02/JS-core/(Day08)%20%E9%9A%B1%E5%90%AB%E8%BD%89%E5%9E%8B%20-%20%E8%BD%89%E6%88%90%20Boolean%20&%20%E5%AF%AC%E9%AC%86%E7%9B%B8%E7%AD%89%20vs%20%E5%9A%B4%E6%A0%BC%E7%9B%B8%E7%AD%89/">(Day08) 隱含轉型 - 轉成 Boolean &amp; 寬鬆相等 vs 嚴格相等</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/02/JS-core/(Day09)%20%E9%81%8B%E7%AE%97%E5%AD%90%E4%B8%AD%E7%9A%84%E5%84%AA%E5%85%88%E6%80%A7%E5%8F%8A%E7%9B%B8%E4%BE%9D%E6%80%A7/">(Day09) 運算子中的優先性及相依性</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/02/JS-core/(Day10)%20%E7%89%A9%E4%BB%B6%E5%9F%BA%E7%A4%8E%E4%BB%8B%E7%B4%B9">(Day10) 物件基礎介紹</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/02/JS-core/(Day11)%20%E7%89%A9%E4%BB%B6%E5%8F%83%E8%80%83%E7%89%B9%E6%80%A7">(Day11) 物件參考特性</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/02/JS-core/(Day12)%20%E7%89%A9%E4%BB%B6%EF%BC%8C%E6%B7%BA%E6%8B%B7%E8%B2%9D&%E6%B7%B1%E6%8B%B7%E8%B2%9D/">(Day12) 物件，淺拷貝/深拷貝</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/02/JS-core/(Day13)%20%E5%87%BD%E5%BC%8F%E5%9F%BA%E7%A4%8E%E8%88%87%E5%8F%83%E6%95%B8%E4%BB%8B%E7%B4%B9/">(Day13) 函式基礎與參數介紹</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/02/JS-core/(Day14)%20%E9%96%89%E5%8C%85%20(Closure)%20%E4%BB%8B%E7%B4%B9/">(Day14) 閉包 (Closure) 介紹</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/02/JS-core/(Day15)%20%E9%96%89%E5%8C%85%E9%80%B2%E9%9A%8E%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%B7%A5%E5%BB%A0%E6%A8%A1%E5%BC%8F%E5%8F%8A%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E3%80%82/">(Day15) 閉包進階使用，工廠模式及私有方法</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/03/JS-core/(Day16)%20this%20%E4%BB%8B%E7%B4%B9%E4%B8%8A%20-%20this%20%E7%9A%84%E6%8C%87%E5%90%91/">(Day-16) this 介紹上 - this 的指向</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/03/JS-core/(Day17)%20this%20%E4%BB%8B%E7%B4%B9%E4%B8%8B%20-%20%E7%B6%81%E5%AE%9A%20this%20%20%E7%9A%84%20call%20&%20apply%20&%20bind%20%E8%88%87%E5%9A%B4%E6%A0%BC%E6%A8%A1%E5%BC%8F/">(Day17) this 介紹下 - 綁定 this 的 call/apply/bind 與嚴格模式</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/03/JS-core/(Day18)%20%E5%8E%9F%E5%9E%8B%E7%89%B9%E6%80%A7%E8%88%87%E7%B9%BC%E6%89%BF/">(Day18) 原型特性與繼承</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/03/JS-core/(Day19)%20%E5%8E%9F%E5%9E%8B%E8%88%87%E5%BB%BA%E6%A7%8B%E5%BC%8F/">(Day 19) 原型與建構式</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/03/JS-core/(Day20)%20Object.create%20%E5%BB%BA%E7%AB%8B%E5%A4%9A%E5%B1%A4%E7%B9%BC%E6%89%BF/">(Day 20) Object.create 建立多層繼承</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/03/JS-core/(Day21)%20ES6%20class%20%E8%AA%9E%E6%B3%95%E7%B3%96/">(Day 21) ES6 class 語法糖</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/03/JS-core/(Day22)%20ES6%20%E7%9A%84%20let%20%E3%80%81const/">(Day 22) ES6 的 let 、const</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/03/JS-core/(Day23)%20ES6%20%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F/">(Day23) ES6 箭頭函式</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/03/JS-core/(Day24)%20%E8%99%95%E7%90%86%E9%9D%9E%E5%90%8C%E6%AD%A5%E7%9A%84%20Promise/">(Day24) 處理非同步的 Promise</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/03/JS-core/(Day25)%20Promise%20%E8%AA%9E%E6%B3%95%E7%B3%96%20async%20&%20await">(Day25) Promise 語法糖 async &amp; await</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/03/JS-core/(Day26)%20%E4%BD%BF%E7%94%A8%20fetch%20%E4%B8%B2%E6%8E%A5%20Ajax/">(Day26) 使用 fetch 串接 Ajax</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/03/JS-core/(Day27)%20ESM%20%E6%A8%A1%E7%B5%84%E5%8C%96%E6%8B%86%E6%AA%94/">(Day27) ESM 模組化拆檔</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/03/JS-core/(Day28)%20ES6%20%E5%B1%95%E9%96%8B%E9%81%8B%E7%AE%97%E5%AD%90%E8%88%87%E5%85%B6%E9%A4%98%E5%8F%83%E6%95%B8/">(Day28) ES6 展開運算子與其餘參數</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/03/JS-core/(Day29)%20ES6%20-%20%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC/">(Day29) ES6 - 解構賦值</a></p>
</li>
<li><p><a href="https://rider159159.github.io/2021/10/03/JS-core/(Day30)%20-%20%E7%9B%AE%E9%8C%84%E8%88%87%E5%AE%8C%E7%B5%90%E5%BF%83%E5%BE%97/">(Day30) - 完結心得</a></p>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這是本人第一次挑戰鐵人賽，雖然這篇幅水了不少文章，不過也終於讓我寫到完賽了 ✧<em>｡ ٩(ˊᗜˋ</em>)و✧*</p>
<h2 id="寫這個主題動機"><a href="#寫這個主題動機" class="headerlink" title="寫這個主題動機"></a>寫這個主題動機</h2><p>因為 JavaScript  這語言奇耙特性出名的多，實做中絕對會因為不瞭解某些特性碰到相關 Bug，即使有上了相關課程，真正碰到 Bug 時變發現自己是一知半解狀況，因此便以核心為主題寫了鐵人賽。</p>
<h2 id="鐵人賽的過程中"><a href="#鐵人賽的過程中" class="headerlink" title="鐵人賽的過程中"></a>鐵人賽的過程中</h2><p>由於沒有寫文章習慣，在本次鐵人賽主題又是 JavaScript 核心部分 ，要用文章介紹核心這種非實做章節，其時有些困難，因此碰到無從下手的主題時，都會先參考好友 <a href="https://hsiangfeng.github.io/">Ray Blog</a> 中的文章再來撰寫，不過每次透過這種方式撰寫，都會讓人猶豫再三，彷彿這種方法就不是自己寫的文章了，不過完賽後只會想說自己真是想太多了，與其想這種問題不如多寫幾篇文章 XD</p>
<h2 id="完賽後的心得"><a href="#完賽後的心得" class="headerlink" title="完賽後的心得"></a>完賽後的心得</h2><p>完賽後最明顯的其實就是，原本一知半解的章節，寫完文章後再回過頭來看會清楚許多，還有比較明顯的就是再看前端面試考題時，雖然仍無法保證答的很好、或是回答正確（很多陷阱提真的坑），但在看這些面試問題時，可以更快理解他的問題點。 </p>
<p>最後還是要感謝<a href="https://ithelp.ithome.com.tw/users/20119486/ironman/3917">好友 Ray</a>， 除了讓我大方開抄 Blog 的文章以外， 也有針對每個主題給予一些建議、參考讓我能夠順利完成本次鐵人賽。</p>
]]></content>
      <categories>
        <category>鐵人賽心得</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>[[Prototype]] 、__proto__ 、 prototype 三者差異</title>
    <url>/2021/10/06/%5B%5BPrototype%5D%5D%20%E3%80%81__proto__%20%E3%80%81%20prototype%20%E4%B8%89%E8%80%85%E5%B7%AE%E7%95%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在開發專案時，有發現 Chrome 的原型似乎被調整了，不過當時專案對原型使用量不大，因此沒特別注意調整什麼，而上個月開始寫鐵人賽時，有提到原型，有稍微深入瞭解一下 JavaScript 的原型發生什麼是了，這邊稍微說明一下。</p>
<h2 id="Prototype-和-proto-的差異"><a href="#Prototype-和-proto-的差異" class="headerlink" title="[[Prototype]] 和 proto 的差異"></a>[[Prototype]] 和 <strong>proto</strong> 的差異</h2><p>目前使用 Chrome 使用任何物件型別的值，點開他底下都會有 <code>[[Prototype]]</code> 他其時就指向該資料的原型，如圖：<br><img src="https://i.imgur.com/td2VUJN.png" alt="`更新後的 [[Prototype]] 原型`"></p>
<p>在過去 JavaScript 並沒有明確規範瀏覽器要如何製作原型這個功能，因此大部分瀏覽器都採用  <code>__proto__</code> 製做原型，不過後面 ECMAScript 有規範，要使用 <code>[[Prototype]]</code>  來製作原型功能。</p>
<p>不過這時大多瀏覽器已經使用  <code>__proto__</code>  的方式製作原型，因此  <code>[[Prototype]]</code>  則是在後續瀏覽器更新，才陸續被實做上去，不過 <code>[[Prototype]]</code> 、<code>__proto__</code> 都是指原型。</p>
<p>也因此你可以看到過去介紹原型文章、影片中資料的原型都會是 <code>__proto__</code> 而非 <code>[[Prototype]]</code> ，這就是之前瀏覽器尚未更新原型部分的關係，如圖：<br><img src="https://i.imgur.com/SJsu342.png" alt="更新前的 __proto__ 原型"></p>
<p>而最近 Chrome 瀏覽器更新， <code>__proto__</code> 則替換成 <code>[[Prototype]]</code> ，但為了避免過去使用 <code>__proto__</code> 開發的網站無法正確運作，因此仍保留 <code>__proto__</code> 方法，關於這部分 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#%E7%B9%BC%E6%89%BF%E5%B1%AC%E6%80%A7">MDN 文件</a>有詳細的說明。</p>
<p>過去可以使用 <code>__proto__</code> 製作原型的方法，如下面範例</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.__proto__.getLast = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> thsi[<span class="built_in">this</span>.length - <span class="number">1</span> ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.getLast)</span><br></pre></td></tr></table></figure>
<p>這種 <code>__proto__</code> 其實不屬於正規 JavaScript 的，他算是瀏覽器建立的方法，也因此實務上都不太會看到這種寫法，不過 Chrome 更新後仍可以支援這種寫法，而正規的原型方法，如：建構函式、 class 等等的對於這個更新使用上也沒有任何差別。</p>
<p>還有一點要特別提的是，目前 Chrome 雖然不確定是什麼原因，不過最底兩層的原型仍會是 <code>__proto__</code> ，如圖<br><img src="https://i.imgur.com/3oXce3h.png"></p>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>而 <code>prototype</code> 則是 正規的 JavaScript 原型方法，在為建構函式新增方法時、原型製作多層串接時，也都會使用這個方法，詳細使用<a href="https://rider159159.github.io/2021/10/03/JS-core/(Day20)%20Object.create%20%E5%BB%BA%E7%AB%8B%E5%A4%9A%E5%B1%A4%E7%B9%BC%E6%89%BF/">過去鐵人賽文章</a>有介紹過。</p>
<h2 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h2><ul>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#%E7%B9%BC%E6%89%BF%E5%B1%AC%E6%80%A7">MDN 文件</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript Core</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaScript Core</tag>
      </tags>
  </entry>
</search>
